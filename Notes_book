---------------------------------------------------------------------------------------------
OS Intefaces
---------------------------------------------------------------------------------------------

System calls

	. fork   () ...................... Create a process
	. exit   () ...................... Terminate the current process
	. wait   () ...................... Wait for a child process to exit
	. kill   ( pid ) ................. Terminate process pid
	. getpid () ...................... Return the current process’s pid
	. sbrk   ( n ) ................... Grow process’s memory by n bytes

	. open   ( filename, flags ) ..... Open a file; the flags indicate read/write
	. read   ( fd, buf, n ) .......... Read n bytes from an open file into buf
	. write  ( fd, buf, n ) .......... Write n bytes to an open file
	. close  ( fd ) .................. Release open file fd
	. dup    ( fd ) .................. Duplicate fd
	. chdir  ( dirname ) ............. Change the current directory
	. mkdir  ( dirname ) ............. Create a new directory
	. mknod  ( name, major, minor ) .. Create a device file
	. fstat  ( fd ) .................. Return info about an open file
	. link   ( f1, f2 ) .............. Create another name (f2) for the file f1
	. unlink ( filename ) ............ Remove a file

	. exec   ( filename, *argv ) ..... Load a file and execute it
	. pipe   ( p ) ................... Create a pipe and return fd’s in p

	. sleep  ( n ) ................... Sleep for n clock ticks


Process and memory

	. process consists of
		. user-space memory (instructions, data, stack)
		. per process state that is private to the kernel??
	. Xv6 can time-share processes?
		. transparently switches the available CPU among the set of
		  processes waiting to execute
	. When a process is not executing Xv6 saves its CPU registers,
	  restoring them when it next runs the process
	. The kernel associates a process identifier (PID) with each process.


	~~~ Fork, wait, exit ~~~

	. A process may create a new process using the _fork_ system call.
	. Fork creates a new 'child' process with exactly the same memory
	  contents as the 'parent'
	. Fork retuns in both the parent and the child??
		. in the parent, fork returns the child's pid
		. in the child, fork returns zero
	. For example:

		int pid = fork();

		if ( pid > 0 )
		{
			printf( "parent: child=%d\n", pid );

			pid = wait();

			printf( "child %d is done\n", pid );
		}
		else if ( pid == 0 )
		{
			printf( "child: exiting\n" );

			exit();
		}
		else
		{
			printf( "fork error\n" );
		}

		. The _exit_ system call causes the calling process to stop executing
		  and to release resources such as memory and open files
		. The _wait_ system call returns the pid of an exited child of the
		  current process?
		  If none of the caller's children has exited, wait waits for one
		  to do so...
		. The following statements might come out in either order depending on
		  whether the parent or child gets to their printf first:

		      parent: child=9000
		      child: exiting

		. After the child exits, the parent's wait returns causin the parent to print

		      parent: child 900 is done

		. Although the child initially has the same memory contents as the parent,
		  the parent and child are executing with different memory and registers.
		  Changing a variable in one does not affect the other.
		  For example, when the return value of 'wait' above is stored into 'pid'
		  in the parent, it remains unchanged in the child (still zero it started as)


	~~~ Exec ~~~

	. The _exec_ system call replaces the calling process's memory with a new
	  memory image loaded from a file stored in the file system...
	. This file must have a particular format which specifies:
		. which part of the file holds instructions
		. which part of the file holds data
		. which instruction to start
		. etc
	. Xv6 uses the ELF format
	. When exec succeeds, it *does not* return to the calling program.
	  Instead, the instructions loaded from the file start executing at the
	  entry point declared in the ELF header
	. Exec takes two arguments:
		. the name of the file containg the executable
		. an array of string arguments
	. For example:

		char *argv[ 3 ];

		argv[ 0 ] = "echo";
		argv[ 1 ] = "hello";
		argv[ 2 ] = 0;

		exec( "/bin/echo", argv );

		printf( "exec error\n" );

		. This fragment replaces the calling program with an instance of the
		  program /bin/echo running with an argument list [ "echo", "hello" ]
		. Most programs ignore the first argument, which is conventionally the name
		  of the program


	~~~ Shell and exec ~~~

	. The Xv6 shell uses the above fragment to run programs on behalf of users

		while ( getcmd( buf ... ) >= 0 )
		{
			...

			if ( fork() == 0 )
			{
				runcmd( parsecmd( buf ) );
			}

			wait();
		}

	. The main loop reads a line of input from the user with 'getcmd'
	. Then it calls 'fork', which creates a copy of the sheell process
	. The parent calls 'wait' while the child runs the command with exec
	. At some point, the program (ex echo) will call exit, which will
	  cause the parent to return from 'wait'


	~~~ Memory ~~~

	. Xv6 allocates most user-space memory implicitly:
		. fork allocates the memory required for the child's copy of
		  the parent's memory
		. exec allocates enough memory to hold the executable file
	. A process that needs more memory at run-time (perhaps for malloc??)
	  can call _sbrk( n )_ to grow its data memory by n bytes.
	  sbrk returns the location of the new memory


	~~~ Users ~~~

	. Xv6 does not provide a notion of users or of protecting one use
	  from another. All processes run as root.


IO and File descriptors

	. A file descriptor is a small integer representing a kernel-managed object
	  that a process may read from or write to
	. A process may obtain a file descriptor by:
		. opening a file, directory, or device
		. creating a pipe
		. duplicating an existing descriptor
	. The file descriptor interface abstracts away the differences between files,
	  pipes, and devices, making them all look like streams of bytes

	. Internally, the kernel uses the fd as an index into a per-process table,
	  such that every process has a private scope of fds starting at zero
	. By convention, a process,
		. reads from fd 0,               standard input,  stdin
		. writes output to fd 1,         standard output, stdout
		. writes error messages to fd 2, standard error,  stderr
	. The shell exploits this convention to impliment IO redirection and pipelines??
	. The shell ensures that it always has three file descriptors open...


	~~~ Read, write ~~~

	. The _read_ and _write_ system calls read bytes from and write bytes to
	  open files named by file descriptors

	. 'read( fd, buf, n)' reads at most n bytes from fd, copies them into buf,
	  and returns number of bytes read
	. Each fd that refers to a files has an offset associated with it??
	. read reads data from the current offset and then advances that offset
	  by the number of bytes read.
	  A subsequent read will return the bytes following the first read.
	. When there are no more bytes to be read, read returns zero, to signal
	  the end of the file

	. 'write( fd, buf, n)' writes n bytes from buf to the fd and returns
	  the number of bytes written
	  Fewer than n bytes are writen only when an error occurs.
	. Like read, write writes data at the current file offset and
	  advances it accordingly

	. The following fragment (which forms the essence of cat) copies
	  data from its stdin to its stdout. If an error occurs, it
	  writes a message to its stderror

		char buf[ 512 ];
		int n;

		for ( ;; )
		{
			n = read( 0, buf, sizeof buf );    // read stdin

			if ( n == 0 )
			{
				break;
			}

			if ( n < 0 )
			{
				fprintf( 2, "read error\n" );  // write stderr
				exit();
			}

			if ( write( 1, buf, n ) != n )     // write stdout
			{
				fprintf( 2, "write error\n" );
				exit();
			}
		}

		. In the snippet above, cat does not know whether it is reading
		  from / writing to a file, console, or a pipe.


	~~~ Close ~~~

	. _close_ releases a file descriptor, making it free for reuse by
	  a future open, pipe, or dup system call


	~~~ IO redirection ~~~

	. A newly allocated fd is always the *lowest numbered unused* descriptor
	  of the current process
	. fork copies the parent's fd table along with its memory, so that
	  the child starts with exactly the same files open as the parent
	. exec replaces the calling process's memory but preserves its file table
	. This behaviour allows the shell to implement IO redirection by
	  	1. forking,
	  	2. reopening chosen fds,
	  	3. and then executing the new program
	. Below is a simplified snippet of code, showing what the shell
	  runs for the command "cat < input.txt"

		char *argv[ 2 ];

		argv[ 0 ] = "cat";
		argv[ 1 ] = 0;

		if ( fork() == 0 )
		{
			close( 0 );                     // close stdout, fd0

			open( "input.txt", O_RDONLY );  // becomes new stdout, fd0

			exec( "cat", argv );
		}

		. After the child closes fd 0, 'open' is guaranteed to use
		  fd 0 for the newly opened "input.txt"

	. Although fork copies the fd table, each underlying file offset
	  is still shared between parent and child.
	. For example:

		if ( fork() == 0 )            // child
		{
			write( 1, "hello ", 6 );
			exit();
		}
		else                          // parent
		{
			wait();
			write( 1, "world\n", 6 );
		}

		. At the end of this fragment, the file attached to
		  fd 1 will contain "hello world\n"
		. The write in the parent (which thanks to wait, runs only
		  after the child is done), picks up where the child left off.
		. This behaviour helps produce sequential output from
		  sequencs of shell commands ex. "(echo hello; echo world) > output.txt"


	~~~ Dup ~~~

	. _dup_ duplicates an existing fd, returning a new one that refers
	  to the same underlying IO object.
	. Both fds share an offset, just as they would in the fds duplicated by fork
	. For example, as an alternate to the above snippet:

		fd = dup( 1 );

		write( 1, "hello", 6 );
		write( fd, "world\n", 6 );

	. dup allows shells to implement commands such as
	  
	  	"ls existing-file non-existing-file > tmp.txt 2>&1"

	  	. The "2>&1" tells ??
	      I.e. send stderror to where ever stdout is being redirected
	    . Both the name of the existing file and the error
	      message for the non-existing file will show up in file "tmp.txt"

	...

	. Two fds share an offset if they are derived from the same orignal fd
	  via fork or dup.
	  Otherwise, fds *do not share offsets* even if they result from open calls
	  for the same file.


Pipes

	. a pipe is a small kernel buffer exposed to processes as a pair
	  of file descriptors, one for reading and one for writing
	. pipes provide a way for processes to communicate

	. The following example runs the program wc (word count) with
	  stdin connected to the read end of a pipe

		int   p    [ 2 ];
		char *argv [ 2 ];

		argv[ 0 ] = "wc";
		argv[ 1 ] = 0;

		pipe( p );            // creates a new pipe and records its
		                      // read fd in p[0] and its write fd in p[1]

		// child
		if ( fork() == 0 )
		{
			close( 0 );       // close stdin

			dup( p[ 0 ] );    // stdin = p[ 0 ]  (pipe's read end)

			close( p[ 0 ] );  // close fd referring to pipe's read end
			close( p[ 1 ] );  // close fd referring to pipe's write end

			exec( "/bin/wc", argv );
		}

		// parent
		else
		{
			close( p[ 0 ] );                        // close fd referring to pipe's read end

			write( p [ 1 ], "hello world\n", 12 );  // write to pipe

			close( p[ 1 ] );                        // close fd referring to pipe's write end
		}

		. After the fork, both parent and hcild have file descriptors
		  referring to the created pipe
		. The child:
			. dups the read end of the pipe onto its fd 0 (stdin),
			. closes its copy of the pipe's file descriptors...
			  (as they are no longer needed?),
			. and execs wc
			. when wc reads from stdin, it reads from p[ 0 ]
		. The parent:
			. closes the read end of the pipe (not used...)
			. writes "hello world\n" to the write end of the pipe,
			. the closes it when done
		. If no data is available, a read on a pipe waits for either:
		  	. data to be written or,
		  	. all fds referring to the pipe's write end (p[1])
		  	  to be closed.
		  	  In this case, read returns 0, just as if the end of a data
		  	  file had been reached.
		. The fact that a pipe read blocks until it is impossible for
		  new data to arrive is one reason that it's important for the
		  child to close the write end of the pipe before executing wc above

	. The Xv6 shell implementes pipelines in a similar way to the
	  snippet above. For example, "grep fork sh.c | wc -l"

		pipe( p );  // connects left end to right end.
		            // left end writes to p[1]
		            // right end reads from p[0]

		// left end
		if ( fork() == 0 )
		{
			close( 1 );
			dup( p[ 1 ] );  // stdout = p[1]

			close( p[ 0 ] );
			close( p[ 1 ] );

			runcmd( pcmd->left );
		}

		// right end
		if ( fork() == 0 )
		{
			close( 0 );
			dup( p[ 0 ] );  // stdin = p[0]

			close( p[ 0 ] );
			close( p[ 1 ] );

			runcmd( pcmd->right );
		}

		close( p[ 0 ] );
		close( p[ 1 ] );

		wait();
		wait();

		. The child process:
			. creates a pipe to connect the left end of the pipeline
			  with the right end,
			. then calls fork and 'runcmd' for both the left and right
			  ends of the pipeline
			. and waits for both to finish

		. The right end of the pipeline may be a command that itself
		  includes a pipe (ex. "a | b | c"), which itself forks two new
		  child processes
		. Thus the shell may create a tree of processes. The leaves of
		  this tree are commands, and the nodes processes that wait
		  until the left and right children are complete

	. Pipes may not seem any more powerful than temporary files.
	  For example,

		echo hello world | wc

		echo hello world > temp.txt;  wc < temp.txt

	. However, they have at least four advantages over temporary
	  files in this situation:

		1. automatically clean themselves up.
		   With file redirection, the shell would have to be
		   careful to remove "temp.txt" when done
		2. can pass arbitrary long streams of data.
		   Whereas file redirection requires enough free space on
		   disk to store all the data.
		3. allow for parallel execution of pipeline stages.
		   Whereas the file approach requires the first program to
		   finish before the second starts ??
		4. if implementing inter-process communication, pipes'
		   *blocking* reads and writes are more efficient than the
		   non-blocking semantics of files.

	. If one application in a pipeline fails, the kernel generats
	  and end-of-file for the next process in the pipeline


File system

	. The Xv6 file system provides:
		. data files - uninterrupted byte arrays
		. directories - named references to data files and other directories
	. The directories form a tree, starting at a special directory
	  called 'root'
	. A path like "/a/b/c" refers to the file or directory named "c"
	  inside the directory named "b" inside the directory named "a"
	  inside the root directory "/"
	. Paths that don't begin with "/" are evaluated relative to the
	  calling process's current directory, which can be changed
	  with the _chdir_ system call
	. Both these code fragments open the same file:

		// Style 1
		chdir( "/a" );
		chdir( "b" );
		open( "c", O_RDONLY );

		// Style 2
		open( "/a/b/c", O_RDONLY );

		. The first style changes the process's current directory
		  to "/a/b"
		. The second style neither refers to nor changes the
		  process's current directory


	~~~ Creating a new file or directory ~~~

	. There are multiple system calls to create a new file or directory:
		. _mkdir_ creates a new directory
		. _open_ with the O_CREATE flag creates a new data file
		. _mknod_ creates a new device file
	. For example:

		mkdir( "/dir" );

		fd = open( "/dir/file", O_CREATE | O_WRONLY );
		close( fd );

		mknod( "/console", 1, 1 );


	~~~ Mknod ~~~

	. _mknod_ creates a file in the file system but the file has no contents.
	. Instead, the file's metadata marks it as a *device* file and records
	  the major and minor device numbers (the two arguments to mknod) which
	  uniquely identify a kernel device
	. When a process later opens the file, the kernel diverts read and write
	  system calls to the kernel device implementation instead of passing
	  the to the file system


	~~~ Fstat ~~~

	. _fstat_ retrieves information about the object a file descriptor
	  refers to.
	. It fills in a "struct stat" defined in stat.h as:

		#define T_DIR  1   // Directory
		#define T_FILE 2   // File
		#define T_DEV  3   // Device

		struct stat
		{
			short type;   // Type of file
			int   dev;    // File system's disk device
			uint  ino;    // Inode number
			short nlink;  // Number of links to file
			uint  size;   // Size of file in bytes
		};


	~~~ Link, unlink ~~~

	. A file's name is distinct from the file itself.
	  The same underlying file, called an *inode* can have multiple names
	  called *links*

	. _link_ system call creates another file system name referring to
	  the same inode as an existing file.
	. For example, this snippet creates a new file named both "a" and "b":

		open( "a", O_CREATE | O_WRONLY );
		link( "a", "b" );

	. Reading from or writing to "a" is the same as to "b"
	. Each inode is identified by a unique inode number.
	  It is possible to determine that "a" and "b" refer to the same
	  underlying contents by inspecting the result of _fstat_:
	  both will return same inode number and link count (in this case 2).

	. _unlink_ removes a name from the file system
	. The file's inode and the disk space holding its content are
	  only freed when:
		. the file's link count is zero,
		. and no file descriptors refer to it
	. For example:

		unlink( "a" );

		. Leaves the inode and dfile content accessible as "b"

	. A temporary inode that will be cleaned up when the process closes
	  fd or exits can be created as follows:

		fd = open( "/tmp/file.txt", O_CREATE | O_RDWR );
		unlink( "/tmp/file.txt" );

		. By removing link, the file's link count is now zero.
		. The only thing keeping it alive is the file descriptor refering to it


	~~~ ... ~~~

	. Shell commands for file system operations are implemented as
	  user-level programs such as 'mkdir', 'ln', 'rm' etc.
	  This allows anyone to extend the shell with new user commands
	  by just adding a new user-level program??
	. One exception is 'cd' which is built into the shell.
	  cd must change the current working directory of the shell itself.
	  If cd were run as a regular command, then the shell would fork a
	  child process, the child process would run cd, and cd would change
	  the child's working directory, not the shell's.


Real world

	. The Unix system call interfaces has been standardized through the
	  Portable Operating System Interface (POSIX)
	. Xv6 is not POSIX compliant:
		. it misses some system calls e.g. lseek
		. partially implements system calls it does have
		. many more
	. Xv6 is a monolithic kernel
	. Xv6 runs on x86 processors (Intel 80386 or later),
	  and much of it's low-level functionality (ex. process implementation)
	  is x86-specific


---------------------------------------------------------------------------------------------
OS organization
---------------------------------------------------------------------------------------------

Intro

	. A key requirement for an OS is to support several activities at once
	. For example using fork, a process can start a new process.
	. The OS must fulfill three requirements:
		. multiplexing
			. The OS must time-share the resources of the computer among
			  these processes
		. isolation
			. The OS must also arrange for isolation between the processes.
			  That is, if one process has a bug and fails, it shouldn't
			  affect processes that don't depend on it
		. interaction
			. The OS must also facilitate interaction between processes,
			  for example pipelines


Abstracting physical resources

	. We work on the assumption that applications do not trust each other
	  (ex. bugs, malicious) and thus a need for isolation.
	. This is in contrast to a co-operative time sharing approach where
	  each application is well behaved and periodically gives up the
	  processor so that other applications can run
	. To this end, applications are forbidden from directly accessing
	  sensitive hardware resources, and instead the resources are
	  abstracted into services.
	. For example:

		...
		. Applications interact with a file system through
		  'open', 'read', 'write', 'close' system calls
		  instead of reading/writing to raw disk sectors.
		. The OS is the one to manage the disk.

		...
		. Switching hardware processors? among processes,
		  saving and restoring register state as necessary,
		  so that applications are oblivious to time-sharing.
		. For example, CPU still shared even if an application
		  is stuck in an infinite loop

		...
		. Processes use 'exec' to build up their memory image,
		  instead of directly interacting with physical memory.
		. This allows the OS to decide where to place a process in memory.
		  If memory is tight, the OS might even store some of
		  the process's data on disk.

		...
		. Many forms of interaction among Unix processes occur via
		  file descriptors
		. E.g. pipelines, ...


User mode, kernel mode, and system calls

	. Strong isolation...
		. If an application makes a mistake, we don't want the OS to fail
		  Instead, the OS should be able to clean up the failed application
		  and continue running other applications
		. Applications shouldn't be able to modify (or even read) the
		  OS's data structures or instructions

	. Processors provide hardware support for isolation
	. x86 for example has two modes in which it can execute instructions:
	  kernel mode and user mode
	. In kernel mode, the processor is allowed to execute privileged instructions
	  such as reading and writing to IO devices (disk, etc.)
	. If an application in user mode attempts to execute a privileged instruction,
	  then the processor doesn't execute the instruction.
	  Instead it switches to kernel mode so that the software in kernel
	  mode can clean up the application, because it did something it
	  shouldn't be doing

	. Processors provide a special instruction that switches the processor
	  from user mode to kernel mode and enters the kernel at an entry
	  point specified by the kernel
	. In x86, 'int' is used for this

	. Once the processor has switched to kernel mode, the kernel can:
		. validate the arguments of the system call,
		. decide whether the application is allowed to perform the
		  requested operation,
		. and then deny it or execute it.
	. It is important that the kernel sets the entry point for
	  transitions. A malicious application for example could enter
	  the kernel at a point where the validation of arguments is skipped.


Kernel organization

	~~~ Monolithic kernel ~~~

	. Entire operating system resides in the kernel so that all
	  system calls run in kernel mode
	. Entire OS runs with full hardware privilege
	. Ex Linux, Xv6
	. Pro - easy for different parts of the OS to cooperate.
	        For example, might ave a buffer cache that can be shared
	        by both the file system and virtual memory system
	. Con - interfaces between different parts of the OS are often complex??
	. Con - kernel mode errors often cause ... stop working and require reboot


	~~~ Microkernel ~~~

	. To reduce the risk of mistakes in kernel, OS designer can minimize
	  amount of OS code that runs in kernel mode, and execute the bulk
	  of it in user mode - microkernel
	. Ex Minix
	. OS services run as user space processes called 'servers'.
	. The kernel provides an inter-process communication mechanism to
	  send messages from one user-mode process to another...
	. For example, if an application like 'shell' wants to read a file,
	  it sends a message to the 'file server' and waits for a response

	. The kernel interface consists of a few low-level functions for:
		. starting functions
		. sending messages
		. accessing device hardware
		. etc.?
	. In this orginaztion style, most of the OS resides in user-level servers


Process overview

	. In Xv6, the process is the unit of isolation
	. The kernel must implement process abstraction with care because
	  a buggy or malicious application may ...
	. Mechanisms used by the kernel to implement processes include:
		. user/kernel mode flag
		. address spaces
		. time-slicing for threads

	. To help enforce isolation, the process abstraction provides the
	  illusion to a program that it has its own private machine...
	. A process provides a program with what appears to be:
		. a private memory system, or address space?
		. its own CPU


	~~~ Page tables ~~~

	. Xv6 uses page tables (which are implemented by hardware??) to
	  give each process its own address space.
	. The x86 page table translates (maps) a virtual address
	  (the address that a x86 instruction manipualtes) to
	  a physical address (the address the CPU sends to main memory)

	. Xv6 maintains a separate page table for each process that
	  defines the process's address space

	  0xFFFF_FFFF ->  ------------------
		              ...               
		              ------------------
		              free memory       
	  0x8040_0000 ->  ------------------  <-
		              text and data         |
	  0x8010_0000 ->  ------------------    | kernel
		              BIOS                  |
	  0x8000_0000 ->  ------------------  <-
		              heap                  |
		              ------------------    |
		              user stack            | user
		              ------------------    |
		              user text and data    |
	  0x0000_0000 ->  ------------------  <-

	. The address space includes the process's user memory
	  starting at virtual address zero
		. instructions come first,
		. followed by global variables,
		. then the stack,
		. then the "heap" area (for malloc) that the process
		  can expand as needed
		. then the kernel's instructions and data

	. A process's page table also serves as the record of the addresses
	  of the physical pages allocated to store the process's memory??


	~~~ ... ~~~

	. The kernel maintains many pieces of state for each process,
	  which it gathers into a 'struct proc'.
	  A process's most important pieces of kernel state are its:
		. page table
		. kernel stack
		. run state

		// Per-process state
		struct proc
		{
			uint              sz;                // Size of process memory (bytes)
			pde_t            *pgdir;             // Page table
			char             *kstack;            // Bottom of kernel stack for this process
			enum procstate    state;             // Process state
			int               pid;               // Process ID
			struct proc      *parent;            // Parent process
			struct trapframe *tf;                // Trap frame for current syscall
			struct context   *context;           // swtch() here to run process
			void             *chan;              // If non-zero, sleeping on chan
			int               killed;            // If non-zero, have been killed
			struct file      *ofile [ NOFILE ];  // Open files
			struct inode     *cwd;               // Current directory
			char              name [ 16 ];       // Process name (debugging)
		};


	. Each process has a thread of execution that executes the process's
	  instructions.
	. A thread can be suspended and later resumed
	. To switch between processes, the kernel suspends the currently
	  running thread and resumes another process's thread

	. Much of the state of a thread (local varialbes, function call return
	  address) is stored on the thread's stacks...
	. Each process has two stacks:
		. user stack
		. kernel stack (p->kstack)
	. When a process is executing user instructions, only its user stack
	  is used. The kernel stack is empty.
	. When the process enters kernel mode (ex. system call or interrupt),
	  the kernel code executes on the process's kernel stack.
	. Because the kernel stack is separate from the user stack, it can
	  execute even if a process has wrecked its user stack

	. When a process makes a system call:
		. the processor switches to the kernel stack,
		. raises the hardware privilege level,
		. and starts executing the kernel instructions that implement the
		  system call
	. When the system call completes, the kernel returns to user space:
		. the hardware lowers privilege level,
		. switches back to the user stack,
		. and resumes executing user instructions just after the
		  system call instruction

	. A process's thread can 'block' in the kernel to wait for IO, and
	  resume were it left off when the IO has finished

	. p->state indicates whether the process is allocated, ready to run,
	  running, waiting for IO, or exiting.

		enum procstate
		{
			UNUSED,
			EMBRYO,
			SLEEPING,
			RUNNABLE,
			RUNNING,
			ZOMBIE
		};

	. p->pgdir holds the process's page table in the format that
	  x86 expects.


The beginning

	. Let's look at how:
		. the kernel creates the first address space (for itself)
		. the kernel creates and starts the first process
		. that process performs the first system call


Creating the first address space

	. The first step in providing strong isolation is setting
	  up the kernel to run in its own address space
	. When a PC powers on, it initializes itself?, and then
	  loads a "boot loader" from disk into memory and executes it
	  starting at "entry" (entry.S)
	. The x86 paging hardware is not enabled when the kernel starts.
	  Virtual addresses map directly to physical addresses.


	~~~ ... ~~~

	. The boot loader loads the Xv6 kernel into memory at
	  physical address 0x0010_0000
	. It does not load the kernel at 0x8010_0000 (where the kernel
	  expects its instructions and data to be) because there may
	  not be any physical memory at that address in a small machine
	. It does not load the kernel at 0x0 because in x86?, the
	  address range 0x000A_0000 .. 0x0010_0000 contains IO devices??
	  https://wiki.osdev.org/Memory_Map_(x86)

	. To allow the rest of? the kernel to run, 'entry' sets up a
	  page table that maps virtual addresses starting at
	  0x8000_0000 (KERNBASE) to physical address starting at 0x0

	  | virtual addr |                  | physical addr |

	  0xFFFF_FFFF ->  ------------------
		              ...               
		              ------------------
		              free memory       
	  0x8040_0000 ->  ------------------  <- 0x0040_0000
		              text and data     
	  0x8010_0000 ->  ------------------  <- 0x0010_0000
		              BIOS              
	  0x8000_0000 ->  ------------------  <- 0x0000_0000


	. The entry page table is defined in "main.c"

		__attribute__( ( __aligned__( PGSIZE ) ) )
		pde_t entrypgdir [ NPDENTRIES ] = {

			// Map VA's [0, 4MB ) to PA's [0, 4MB )
			[ 0 ]                    = ( 0 ) | PTE_P | PTE_W | PTE_PS,

			// Map VA's [KERNBASE, KERNBASE+4MB ) to PA's [0, 4MB )
			[ KERNBASE >> PDXSHIFT ] = ( 0 ) | PTE_P | PTE_W | PTE_PS,
		};


	. entry[0]? maps virtual addresses 0 .. 0x0040_0000 to
	  physical addresses 0 .. 0x0040_0000
	. This mapping is required as long as entry is executing
	  at low address, but will eventually be removed

	. entry[512]? maps virtual address KERNBASE .. KERNBASE + 0x0040_0000 to
	  physical addresses 0 .. 0x0040_0000
	. This mapping will be used by the kernel after 'entry'
	  has finished
	. It maps the high virtual address the kernel expects to
	  find its instructions and data to the low physical address
	  where the boot loader loaded them
	. This mapping restricts the kernel instructions and data
	  to 4 Mbytes (0x0040_0000)

		  KERNBASE >> PDXSHIFT
		= 0x80000000 >> 22
		= 512


	~~~ Set page directory ~~~

	. "entry.S" first loads the physical address of "entrypgdir"
	  into the control register (cr3)
	. The symbol 'entrypgdir' refers to an address in high memory.
	  The macro V2P_WO subtracts KERNBASE in order to get the
	  physical address

		/// entry.S ///

		movl  $( V2P_WO( entrypgdir ) ), %eax
		movl  %eax, %cr3


		/// memlayout.h ///

		#define V2P_WO ( x ) ( ( x ) - KERNBASE )


	~~~ Enable paging hardware ~~~

	. To enable paging hardware, Xv6 sets the CR0_PG flag in
	  the control register (cr0)

		movl  %cr0, %eax
		orl   $( CR0_PG | CR0_WP ), %eax
		movl  %eax, %cr0


	~~~ Transfer to kernel's C code and run it in high memory ~~~

	. First makes the stack pointer (esp) point to the memory
	  location to be used as a stack
	. Then jumps to main.
	  An indirect jump is needed because the assembler would
	  otherwise generate a PC-relative direct jump...

		/// entry.S ///

		entry:

			...

			movl $( stack + KSTACKSIZE ), %esp

			mov $main, %eax
			jmp *%eax

		.comm stack, KSTACKSIZE  // allocate space...


		/// param.h ///

		#define KSTACKSIZE 4096  // size of per-process kernel stack


	. Now the kernel is running in high addresses in the
	  function "main" ("main.c")

Creating the first process

	. We will now look at how the kernel creates user-level
	  processes and ensures that they are strongly isolated


	~~~ allocproc, kernel stack ~~~

	. After main initializes several devices and subsytems,
	  it creates the first process by calling "userinit"
	. userinit's first action is to call "allocproc"

	. "allocproc" job is to:
		. allocate a slot (a struct proc) in the process table, and
		. to initialize the parts of the process's state
		  required for its kernel thread to execute ??

	. allocproc is called for each new process, while
	  userinit is called only once for the very first process
	. allocproc is written so that it can also be used by 'fork'

	. allocproc sets up the new process with a specially prepared
	  kernel stack and set of kernel registers that will cause ? to
	  "return" to user space when it first runs

	. allocproc first scans the "proc" table for a slot with state UNUSED 

		for ( p = ptable.proc; p < &ptable.proc[ NPROC ]; p += 1 )
		{
			if ( p->state == UNUSED )
			{
				goto found;
			}
		}

	. When it finds an unused slot, allocproc sets the state to
	  EMBRYO, to mark it as used and gives the process a unique pid

		p->state = EMBRYO;
		p->pid   = nextpid;

		nextpid += 1;

	. Next it tries to allocate a kernel stack for the process's
	  kernel thread.
	. If the memory allocation fails, allocproc changes the
	  state back to UNUSED and return zero to signal failure.

		if( ( p->kstack = kalloc() ) == 0 )
		{
			p->state = UNUSED;

			return 0;
		}

		sp = p->kstack + KSTACKSIZE;


	. Now allocproc must setup the kernel stack to look like this:

	---------------  <-- p->kstack + KSTACKSIZE
	trapframe
	(initialized
	 as if entered
	 kernel via
	 interrupt)
	---------------  <-- p->tf
	trapret
	---------------  <-- address forkret will return to (p->tf - 4)
	context
	(eip = forkret,
	 others 0)
	---------------  <-- p->context
	empty
	...
	---------------  <-- p->kstack


	. It does this as follows:

		/// proc.c ///

		// Leave room for trap frame.
		sp -= sizeof *p->tf;
		p->tf = ( struct trapframe* )sp;

		// Set up new context to start executing at forkret,
		// which returns to trapret.
		sp -= 4;
		*( uint* )sp = ( uint )trapret;

		// Setup register contents that 
		sp -= sizeof *p->context;
		p->context = ( struct context* )sp;

		memset( p->context, 0, sizeof *p->context );

		p->context->eip = ( uint )forkret;


		/// proc.h ///

		struct context
		{
			uint edi;
			uint esi;
			uint ebx;
			uint ebp;
			uint eip;
		};

	. The code sets up program counter return values that will
	  cause the kernel thread to first execute 'forkret'
	  and then 'trapret'
	. The kernel thread will start executing with the
	  register contents (edi, esi, ebx, ebp, eip) in p->context.
	  Since p->context->eip is set to 'forkret', that is where
	  the kernel thread will start executing

		// A fork child's very first scheduling by scheduler()
		// will swtch here.  "Return" to user space.
		void forkret ( void )
		{
			static int first = 1;

			...

			if ( first )
			{
				// Some initialization functions must be run in the context
				// of a regular process ( e.g., they call sleep ), and thus cannot
				// be run from main().
				first = 0;

				iinit( ROOTDEV );

				initlog( ROOTDEV );
			}

			// Return to "caller", actually trapret ( see allocproc ).
		}

	. 'forkret' will return to whatever address is at the
	  bottom of the stack.
	  allocproc has placed the address of 'trapret' here
	. trapret restores user registers from values stored
	  at the top of the kernel stack, and jumps into the process??

		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret

	. The context switch code (swtch.S) sets the stack pointer
	  to point just beyond the end of p->context,
	  where in this case, allocproc has placed the address of trapret
	. Control transfers from user software to the kernel via
	  an interrupt mechanism which is used by system calls,
	  interrupts, and exceptions
	. Whenever control transfers into the kernel while a
	  process is running, the hardware and xv6 "trap entry code"??
	  save user registers onto the process's kernel stack

		/// x86.h ///

		// Layout of the trap frame built on the stack by the
		// hardware and by trapasm.S, and passed to trap().
		struct trapframe
		{
			// registers as pushed by pusha
			uint edi;
			uint esi;
			uint ebp;
			uint oesp;  // useless & ignored
			uint ebx;
			uint edx;
			uint ecx;
			uint eax;

			// rest of trap frame
			ushort gs;
			ushort padding1;
			ushort fs;
			ushort padding2;
			ushort es;
			ushort padding3;
			ushort ds;
			ushort padding4;
			uint   trapno;

			// below here defined by x86 hardware
			uint   err;
			uint   eip;
			ushort cs;
			ushort padding5;
			uint   eflags;

			// below here only when crossing rings, such as from user to kernel
			uint   esp;
			ushort ss;
			ushort padding6;
		};


		/// trapasm.S ///

		alltraps:

			# Build trap frame.
			pushl   %ds
			pushl   %es
			pushl   %fs
			pushl   %gs
			pushal
			
			# Set up data segments.
			movw    $( SEG_KDATA << 3 ), %ax
			movw    %ax, %ds
			movw    %ax, %es

			# Call trap( tf ), where tf = %esp
			pushl   %esp
			call    trap
			addl    $4, %esp

		# Return falls through to trapret...
		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret


	. after allocproc, 'userinit' writes values to the
	  trapframe at the top of the stack that make it look
	  just like what would be there if the process had entered
	  the kernel via an interrupt.
	. This allows the ordinary code (?) for returning from the
	  kernel back to the process's user code to work.

		memset( p->tf, 0, sizeof( *p->tf ) );

		p->tf->cs     = ( SEG_UCODE << 3 ) | DPL_USER;
		p->tf->ds     = ( SEG_UDATA << 3 ) | DPL_USER;
		p->tf->es     = p->tf->ds;
		p->tf->ss     = p->tf->ds;
		p->tf->eflags = FL_IF;
		p->tf->esp    = PGSIZE;
		p->tf->eip    = 0;  // beginning of initcode.S

	. Now the kernel stack is completely prepared
	  (see above diagram)


	~~~ page table, address space ~~~

	. The first process is going to execute a small
	  program (initcode.S)
	. The process needs:
		. physical memory in which to store this program.
		. a page table that maps user-space addresses to
		  that memory

	. userinit calls 'setupkvm' to create a page table for
	  the process

{{}}



. At a high level, userinit creates a process address space
  as shown in earlier diagram



how does swtch get executed?

userinit()
mpmain() -> scheduler() -> swtch()



BIOS -> entry() -> main()






/// swtch.S ///

swtch:

	movl   4( %esp ), %eax
	movl   8( %esp ), %edx

	# Save old callee-saved registers
	pushl  %ebp
	pushl  %ebx
	pushl  %esi
	pushl  %edi

	# Switch stacks
	movl   %esp, ( %eax )
	movl   %edx, %esp

	# Load new callee-saved registers
	popl   %edi
	popl   %esi
	popl   %ebx
	popl   %ebp
	ret







Running the first process

	. 

The first system call: exec

	.
































---------------------------------------------------------------------------------------------
Page tables
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
Traps, interupts, and drivers
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
Locking
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
Scheduling
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
File system
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
Summary
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
PC hardware
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
The boot loader
---------------------------------------------------------------------------------------------

...

	. When a x86 PC boots, it starts executing a program called the BIOS
	  (Basic Input/Output System) which is stored in non-volatile memory
	  on the motherboard
	. The BIOS's job is to prepare the hardware and then transfer control
	  to the OS
	. Specifically, it transfers control to code loaded from the
	  *boot sector* - the first 512 byte sector of the boot disk...
	. The boot sector contains the *boot loader* - instructions that
	  load the kernel into memory

	. The BIOS loads the boot sector at memory address 0x7C00 and then
	  jumps (sets the CPU's instruction pointer) to that address

	. When the boot loader begins executing, the CPU is simulating
	  an Intel 8088
	. The loader's job is to:
		. put the processor in a more modern operating mode,
		. load the Xv6 kernel from disk into memory,
		. and then transfer control to the kernel

	. The Xv6 bootloader comprises two files:
		. "bootasm.S" - written in a combniation of 16bit and 32bit assembly
		. "bootmain.c"

Assembly bootstrap

	. The first instruction in the boot loader is "cli", which disables
	  processor interrupts
	. The BIOS is a tiny OS and it might have setup its own interrupt
	  handlers as part of initializing the hardware
	. When Xv6 is ready, it will re-enable interrupts

	. The processor is in real mode, and is simulating an Intel 8088


	~~~ Real mode addressing ~~~

	. In real mode there are eight 16bit general purpose registeres
	. Since the processor sends 20bits of address to memory,
	  16bit segment registers (cs, ds, es, ss) are used to provide
	  the additional bits
	. Which segment register is used is implied by the type of
	  memory reference:
		. cs - instruction fetches
		. ds - data read and write
		. ss - stack read and write
	. When a program refers to memory, the CPU automatically
	  adds 16 times the value of a segment ergister...
	  The generated address is called the "linear address"

	. Xv6 pretends that an x86 instruction uses a "virtual address"
	  for its memory operands?? but an instruction actually uses
	  a "logical address"??
	. A "logical address" consists of a segment selector and an
	  offset.
	. It is sometimes written as "segment:offset".
	  More often the segment is implicit, and the program only
	  directly manipulates the offset

	. The segmentation hardware transforms the "logical address"
	  into a "linear address"
	. If paging hardware is enabled, it translates linear addresses
	  into "physical addresses".
	  Otherwise the processor uses linear addresses as physical

	  ------------
	  CPU
	  ------------
	       |
	       |       <--- logical address
	       V
	  ------------
	  segmentation
	  hardware
	  ------------
	       |
	       |       <--- linear address
	       V
	  ------------
	  paging
	  hardware
	  ------------
	       |
	       |       <--- physical address
	       V
	  ------------
	  RAM
	  ------------

	. After cli, the next thing the boot loader does is set
	  the segment registers to zero (known state)

		xorw   %ax, %ax   # Set %ax to zero
		movw   %ax, %ds   # -> Data Segment
		movw   %ax, %es   # -> Extra Segment
		movw   %ax, %ss   # -> Stack Segment

	. The next step is some hack to compensate for the fact
	  that a virtual "segment:offset" can yield a 21bit
	  physical address, whereas the Intel 8088 can only address
	  20bits of memory

		seta20.1:
			...

		seta20.2:
			...


	~~~ Switching to protected mode ~~~

	. The next step is to switch to 32bit "protected mode"

	. In protected mode, a segment register is an index into a
	  "segment descriptor table"...
	. Each entry in the table specifies:
		. a base physical address,
	  	. a maximum virtual address called the limit,
	  	. and permission bits for the segment
	. These permissions are the protection in protected mode.
	  The kernel can use them to ensure that a program uses only
	  its own memory

		 ... | ...   | ...      
		-----|-------|------
		base | limit | flags
		-----|-------|------
		base | limit | flags
		-----|-------|------
		base | limit | flags
		--------------------

	. Xv6 makes no use of segments, and uses the paging hardware instead
	. The boot loader sets up the segment descriptor table "gdt"
	  so that all segments:
		. have a base address of zero,
		. and the maximum possible limit (4Gbytes)
	. The table has three entries:??
		. a null entry,
		. one for executable code,
		. one for data
	. The code segment descriptor has a flag set (STA_X) that indicates
	  the code should run in 32bit mode...

	. The boot loader executes an "lgdt" instruction to load
	  the processor's GDT register with the value "gdtdesc"
	  which points to table gdt...

	. Once it has loaded the GDT register, the boot loader
	  enables protected mode by setting the appropriate
	  bit (CR0_PE) in the control register (cr0).

		/// bootasm.S ///

		lgdt  gdtdesc

		movl  %cr0,    %eax
		orl   $CR0_PE, %eax
		movl  %eax,    %cr0

		gdt:

			SEG_NULLASM                                # null seg
			SEG_ASM( STA_X | STA_R, 0x0, 0xffffffff )  # code seg
			SEG_ASM( STA_W, 0x0, 0xffffffff )          # data seg

		gdtdesc:

			.word  ( gdtdesc - gdt - 1 )  # sizeof( gdt ) - 1
			.long  gdt                    # address gdt


		/// asm.h ///

		#define STA_X  0x8  // Executable segment
		#define STA_W  0x2  // Writeable (non-executable segments)
		#define STA_R  0x2  // Readable (executable segments)

		#define SEG_NULLASM   \
			.word 0, 0;       \
			.byte 0, 0, 0, 0

		#define SEG_ASM ( type, base, lim )               \
			.word ( ( ( lim ) >> 12 ) & 0xffff ),         \
			      ( ( base ) & 0xffff );                  \
			.byte ( ( ( base ) >> 16 ) & 0xff ),          \
			      ( 0x90 | ( type ) ),                    \
			      ( 0xC0 | ( ( ( lim ) >> 28 ) & 0xf ) ), \
			      ( ( ( base ) >> 24 ) & 0xff )


	. Setting CR0_PE does not immediately change how the processor
	  translates logical addresses to physical.
	. The change takes effect only when one loads a new value
	  into a segment register...
	  A hack to do this is the following snippet which
	  writes the cs register...

		ljmpl  $( SEG_KCODE << 3 ), $( start32 )

		start32:
			...


	~~~ 32bit mode ~~~

	. The boot loader's first action in 32bit mode is to
	  initialize the data segment register (?) with SEG_KDATA

		movw  $( SEG_KDATA << 3 ), %ax  # Our data segment selector
		movw  %ax, %ds                  # -> DS: Data Segment
		movw  %ax, %es                  # -> ES: Extra Segment
		movw  %ax, %ss                  # -> SS: Stack Segment
		movw  $0,  %ax                  # Zero segments not ready for use
		movw  %ax, %fs                  # -> FS
		movw  %ax, %gs                  # -> GS

	. The next step before executing C code is to set up a stack
	  in an unused region of memory.
	. The boot loader chooses 0x7C00 as the top of the stack.
	  The stack will grow down from here, towards 0x0000 and
	  away from the boot loader

		start:

			cli

			...
		
			movl $start, %esp

			call bootmain


	. Memory looks like this...

		0xFFFF_FFFF -> --------------
		               ?
		0x0040_0000 -> --------------
		               reserved for kernel (Xv6 expects to be loaded here)
		0x0010_0000 -> --------------
		               IO devices?
		0x000A_0000 -> --------------
		               ?
		0x0000_7E00 -> --------------
		               boot loader (512 bytes)
		0x0000_7C00 -> --------------
		               stack
		0x0000_0000 -> --------------


	. The boot loader then calls the C function "bootmain"
	  which will load and run the kernel

C bootstrap

	. bootmain expects to find a copy of the kernel executable
	  on the disk starting at the second sector?
	. The kernel is an ELF format binary
	. To get access to the ELF headers, bootmain loads
	  the first 4096 bytes of the binary.
	  It places the in memory copy at address 0x0001_0000

		// ?
		elf = ( struct elfhdr* )0x10000;  // scratch space

		// Read 1st page off disk
		readseg( ( uchar* )elf, 4096, 0 );


	. The next step is a quick check that the ELF is a binary
	  and not an unitialized disk

		if ( elf->magic != ELF_MAGIC )
		{
			return;  // let bootasm.S handle error
		}


	. Bootmain then loads the content after the ELF header
	  into the memory address specified in kernel.ld
	. And zeros the remainder of the segment...

	. The kernel has been compiled and linked so that it
	  expects to find itself at virtual addresses starting
	  at 0x8010_0000
	. This virtual address is configured in kernel.ld
	. Once the kernel starts executing, it will set up the
	  paging hardware to map virtual addresses starting
	  at 0x8010_0000 to physical addresses starting at
	  0x0010_0000
	. This physical address is configured in kernel.ld
	. The boot loader uses this physical address
	  as where to load the kernel into memory

		ph = elf + elf->phoff;  // get program header

		pa = ph->paddr;         // get physical address of segment...


	. The boot loader's final step is to call the kernel's
	  entry point - the instruction the kernel expects to
	  start executing.
	. For Xv6 this address is 0x0010_000C
	. By convention, the "_start" symbol specifies the ELF
	  entry point
	. For Xv6, this is defined in "entry.S"

		# objdump -f kernel

		kernel:           file format elf32-i386
		architecture:     i386
		flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED
		start address:    0x0010000c


		// bootmain.c //
		entry = ( void( * )( void ) )( elf->entry );

		entry();


JK Summary

	. Most of this is legacy bloat.
	. Nothing useful happens here apart from the following:
		. load kernel from disk to where it expects to be in memory (RAM),
		. and jump to _start (entry.S)


---------------------------------------------------------------------------------------------
Other
---------------------------------------------------------------------------------------------

x86 processor supports Xv6 via:

	. kernel and user mode
		. switch between two
			. 'sysenter', 'sysexit' instructions
		. priviledged instructions
		. detect when user mode trying to execute priviledged

	. page table ??
		. translate virtual addresses to physical...





