---------------------------------------------------------------------------------------------
OS Intefaces
---------------------------------------------------------------------------------------------

System calls

	. fork   () ...................... Create a process
	. exit   () ...................... Terminate the current process
	. wait   () ...................... Wait for a child process to exit
	. kill   ( pid ) ................. Terminate process pid
	. getpid () ...................... Return the current process’s pid
	. sbrk   ( n ) ................... Grow process’s memory by n bytes

	. open   ( filename, flags ) ..... Open a file; the flags indicate read/write
	. read   ( fd, buf, n ) .......... Read n bytes from an open file into buf
	. write  ( fd, buf, n ) .......... Write n bytes to an open file
	. close  ( fd ) .................. Release open file fd
	. dup    ( fd ) .................. Duplicate fd
	. chdir  ( dirname ) ............. Change the current directory
	. mkdir  ( dirname ) ............. Create a new directory
	. mknod  ( name, major, minor ) .. Create a device file
	. fstat  ( fd ) .................. Return info about an open file
	. link   ( f1, f2 ) .............. Create another name (f2) for the file f1
	. unlink ( filename ) ............ Remove a file

	. exec   ( filename, *argv ) ..... Load a file and execute it
	. pipe   ( p ) ................... Create a pipe and return fd’s in p

	. sleep  ( n ) ................... Sleep for n clock ticks


Process and memory

	. process consists of
		. user-space memory (instructions, data, stack)
		. per process state that is private to the kernel??
	. Xv6 can time-share processes?
		. transparently switches the available CPU among the set of
		  processes waiting to execute
	. When a process is not executing Xv6 saves its CPU registers,
	  restoring them when it next runs the process
	. The kernel associates a process identifier (PID) with each process.


	~~~ Fork, wait, exit ~~~

	. A process may create a new process using the _fork_ system call.
	. Fork creates a new 'child' process with exactly the same memory
	  contents as the 'parent'
	. Fork retuns in both the parent and the child??
		. in the parent, fork returns the child's pid
		. in the child, fork returns zero
	. For example:

		int pid = fork();

		if ( pid > 0 )
		{
			printf( "parent: child=%d\n", pid );

			pid = wait();

			printf( "child %d is done\n", pid );
		}
		else if ( pid == 0 )
		{
			printf( "child: exiting\n" );

			exit();
		}
		else
		{
			printf( "fork error\n" );
		}

		. The _exit_ system call causes the calling process to stop executing
		  and to release resources such as memory and open files
		. The _wait_ system call returns the pid of an exited child of the
		  current process?
		  If none of the caller's children has exited, wait waits for one
		  to do so...
		. The following statements might come out in either order depending on
		  whether the parent or child gets to their printf first:

		      parent: child=9000
		      child: exiting

		. After the child exits, the parent's wait returns causin the parent to print

		      parent: child 900 is done

		. Although the child initially has the same memory contents as the parent,
		  the parent and child are executing with different memory and registers.
		  Changing a variable in one does not affect the other.
		  For example, when the return value of 'wait' above is stored into 'pid'
		  in the parent, it remains unchanged in the child (still zero it started as)


	~~~ Exec ~~~

	. The _exec_ system call replaces the calling process's memory with a new
	  memory image loaded from a file stored in the file system...
	. This file must have a particular format which specifies:
		. which part of the file holds instructions
		. which part of the file holds data
		. which instruction to start
		. etc
	. Xv6 uses the ELF format
	. When exec succeeds, it *does not* return to the calling program.
	  Instead, the instructions loaded from the file start executing at the
	  entry point declared in the ELF header
	. Exec takes two arguments:
		. the name of the file containg the executable
		. an array of string arguments
	. For example:

		char *argv[ 3 ];

		argv[ 0 ] = "echo";
		argv[ 1 ] = "hello";
		argv[ 2 ] = 0;

		exec( "/bin/echo", argv );

		printf( "exec error\n" );

		. This fragment replaces the calling program with an instance of the
		  program /bin/echo running with an argument list [ "echo", "hello" ]
		. Most programs ignore the first argument, which is conventionally the name
		  of the program


	~~~ Shell and exec ~~~

	. The Xv6 shell uses the above fragment to run programs on behalf of users

		while ( getcmd( buf ... ) >= 0 )
		{
			...

			if ( fork() == 0 )
			{
				runcmd( parsecmd( buf ) );
			}

			wait();
		}

	. The main loop reads a line of input from the user with 'getcmd'
	. Then it calls 'fork', which creates a copy of the sheell process
	. The parent calls 'wait' while the child runs the command with exec
	. At some point, the program (ex echo) will call exit, which will
	  cause the parent to return from 'wait'


	~~~ Memory ~~~

	. Xv6 allocates most user-space memory implicitly:
		. fork allocates the memory required for the child's copy of
		  the parent's memory
		. exec allocates enough memory to hold the executable file
	. A process that needs more memory at run-time (perhaps for malloc??)
	  can call _sbrk( n )_ to grow its data memory by n bytes.
	  sbrk returns the location of the new memory


	~~~ Users ~~~

	. Xv6 does not provide a notion of users or of protecting one use
	  from another. All processes run as root.


IO and File descriptors

	. A file descriptor is a small integer representing a kernel-managed object
	  that a process may read from or write to
	. A process may obtain a file descriptor by:
		. opening a file, directory, or device
		. creating a pipe
		. duplicating an existing descriptor
	. The file descriptor interface abstracts away the differences between files,
	  pipes, and devices, making them all look like streams of bytes

	. Internally, the kernel uses the fd as an index into a per-process table,
	  such that every process has a private scope of fds starting at zero
	. By convention, a process,
		. reads from fd 0,               standard input,  stdin
		. writes output to fd 1,         standard output, stdout
		. writes error messages to fd 2, standard error,  stderr
	. The shell exploits this convention to impliment IO redirection and pipelines??
	. The shell ensures that it always has three file descriptors open...


	~~~ Read, write ~~~

	. The _read_ and _write_ system calls read bytes from and write bytes to
	  open files named by file descriptors

	. 'read( fd, buf, n)' reads at most n bytes from fd, copies them into buf,
	  and returns number of bytes read
	. Each fd that refers to a files has an offset associated with it??
	. read reads data from the current offset and then advances that offset
	  by the number of bytes read.
	  A subsequent read will return the bytes following the first read.
	. When there are no more bytes to be read, read returns zero, to signal
	  the end of the file

	. 'write( fd, buf, n)' writes n bytes from buf to the fd and returns
	  the number of bytes written
	  Fewer than n bytes are writen only when an error occurs.
	. Like read, write writes data at the current file offset and
	  advances it accordingly

	. The following fragment (which forms the essence of cat) copies
	  data from its stdin to its stdout. If an error occurs, it
	  writes a message to its stderror

		char buf[ 512 ];
		int n;

		for ( ;; )
		{
			n = read( 0, buf, sizeof buf );    // read stdin

			if ( n == 0 )
			{
				break;
			}

			if ( n < 0 )
			{
				fprintf( 2, "read error\n" );  // write stderr
				exit();
			}

			if ( write( 1, buf, n ) != n )     // write stdout
			{
				fprintf( 2, "write error\n" );
				exit();
			}
		}

		. In the snippet above, cat does not know whether it is reading
		  from / writing to a file, console, or a pipe.


	~~~ Close ~~~

	. _close_ releases a file descriptor, making it free for reuse by
	  a future open, pipe, or dup system call


	~~~ IO redirection ~~~

	. A newly allocated fd is always the *lowest numbered unused* descriptor
	  of the current process
	. fork copies the parent's fd table along with its memory, so that
	  the child starts with exactly the same files open as the parent
	. exec replaces the calling process's memory but preserves its file table
	. This behaviour allows the shell to implement IO redirection by
	  	1. forking,
	  	2. reopening chosen fds,
	  	3. and then executing the new program
	. Below is a simplified snippet of code, showing what the shell
	  runs for the command "cat < input.txt"

		char *argv[ 2 ];

		argv[ 0 ] = "cat";
		argv[ 1 ] = 0;

		if ( fork() == 0 )
		{
			close( 0 );                     // close stdout, fd0

			open( "input.txt", O_RDONLY );  // becomes new stdout, fd0

			exec( "cat", argv );
		}

		. After the child closes fd 0, 'open' is guaranteed to use
		  fd 0 for the newly opened "input.txt"

	. Although fork copies the fd table, each underlying file offset
	  is still shared between parent and child.
	. For example:

		if ( fork() == 0 )            // child
		{
			write( 1, "hello ", 6 );
			exit();
		}
		else                          // parent
		{
			wait();
			write( 1, "world\n", 6 );
		}

		. At the end of this fragment, the file attached to
		  fd 1 will contain "hello world\n"
		. The write in the parent (which thanks to wait, runs only
		  after the child is done), picks up where the child left off.
		. This behaviour helps produce sequential output from
		  sequencs of shell commands ex. "(echo hello; echo world) > output.txt"


	~~~ Dup ~~~

	. _dup_ duplicates an existing fd, returning a new one that refers
	  to the same underlying IO object.
	. Both fds share an offset, just as they would in the fds duplicated by fork
	. For example, as an alternate to the above snippet:

		fd = dup( 1 );

		write( 1, "hello", 6 );
		write( fd, "world\n", 6 );

	. dup allows shells to implement commands such as
	  
	  	"ls existing-file non-existing-file > tmp.txt 2>&1"

	  	. The "2>&1" tells ??
	      I.e. send stderror to where ever stdout is being redirected
	    . Both the name of the existing file and the error
	      message for the non-existing file will show up in file "tmp.txt"

	...

	. Two fds share an offset if they are derived from the same orignal fd
	  via fork or dup.
	  Otherwise, fds *do not share offsets* even if they result from open calls
	  for the same file.


Pipes

	. a pipe is a small kernel buffer exposed to processes as a pair
	  of file descriptors, one for reading and one for writing
	. pipes provide a way for processes to communicate

	. The following example runs the program wc (word count) with
	  stdin connected to the read end of a pipe

		int   p    [ 2 ];
		char *argv [ 2 ];

		argv[ 0 ] = "wc";
		argv[ 1 ] = 0;

		pipe( p );            // creates a new pipe and records its
		                      // read fd in p[0] and its write fd in p[1]

		// child
		if ( fork() == 0 )
		{
			close( 0 );       // close stdin

			dup( p[ 0 ] );    // stdin = p[ 0 ]  (pipe's read end)

			close( p[ 0 ] );  // close fd referring to pipe's read end
			close( p[ 1 ] );  // close fd referring to pipe's write end

			exec( "/bin/wc", argv );
		}

		// parent
		else
		{
			close( p[ 0 ] );                        // close fd referring to pipe's read end

			write( p [ 1 ], "hello world\n", 12 );  // write to pipe

			close( p[ 1 ] );                        // close fd referring to pipe's write end
		}

		. After the fork, both parent and hcild have file descriptors
		  referring to the created pipe
		. The child:
			. dups the read end of the pipe onto its fd 0 (stdin),
			. closes its copy of the pipe's file descriptors...
			  (as they are no longer needed?),
			. and execs wc
			. when wc reads from stdin, it reads from p[ 0 ]
		. The parent:
			. closes the read end of the pipe (not used...)
			. writes "hello world\n" to the write end of the pipe,
			. the closes it when done
		. If no data is available, a read on a pipe waits for either:
		  	. data to be written or,
		  	. all fds referring to the pipe's write end (p[1])
		  	  to be closed.
		  	  In this case, read returns 0, just as if the end of a data
		  	  file had been reached.
		. The fact that a pipe read blocks until it is impossible for
		  new data to arrive is one reason that it's important for the
		  child to close the write end of the pipe before executing wc above

	. The Xv6 shell implementes pipelines in a similar way to the
	  snippet above. For example, "grep fork sh.c | wc -l"

		pipe( p );  // connects left end to right end.
		            // left end writes to p[1]
		            // right end reads from p[0]

		// left end
		if ( fork() == 0 )
		{
			close( 1 );
			dup( p[ 1 ] );  // stdout = p[1]

			close( p[ 0 ] );
			close( p[ 1 ] );

			runcmd( pcmd->left );
		}

		// right end
		if ( fork() == 0 )
		{
			close( 0 );
			dup( p[ 0 ] );  // stdin = p[0]

			close( p[ 0 ] );
			close( p[ 1 ] );

			runcmd( pcmd->right );
		}

		close( p[ 0 ] );
		close( p[ 1 ] );

		wait();
		wait();

		. The child process:
			. creates a pipe to connect the left end of the pipeline
			  with the right end,
			. then calls fork and 'runcmd' for both the left and right
			  ends of the pipeline
			. and waits for both to finish

		. The right end of the pipeline may be a command that itself
		  includes a pipe (ex. "a | b | c"), which itself forks two new
		  child processes
		. Thus the shell may create a tree of processes. The leaves of
		  this tree are commands, and the nodes processes that wait
		  until the left and right children are complete

	. Pipes may not seem any more powerful than temporary files.
	  For example,

		echo hello world | wc

		echo hello world > temp.txt;  wc < temp.txt

	. However, they have at least four advantages over temporary
	  files in this situation:

		1. automatically clean themselves up.
		   With file redirection, the shell would have to be
		   careful to remove "temp.txt" when done
		2. can pass arbitrary long streams of data.
		   Whereas file redirection requires enough free space on
		   disk to store all the data.
		3. allow for parallel execution of pipeline stages.
		   Whereas the file approach requires the first program to
		   finish before the second starts ??
		4. if implementing inter-process communication, pipes'
		   *blocking* reads and writes are more efficient than the
		   non-blocking semantics of files.

	. If one application in a pipeline fails, the kernel generats
	  and end-of-file for the next process in the pipeline


File system

	. The Xv6 file system provides:
		. data files - uninterrupted byte arrays
		. directories - named references to data files and other directories
	. The directories form a tree, starting at a special directory
	  called 'root'
	. A path like "/a/b/c" refers to the file or directory named "c"
	  inside the directory named "b" inside the directory named "a"
	  inside the root directory "/"
	. Paths that don't begin with "/" are evaluated relative to the
	  calling process's current directory, which can be changed
	  with the _chdir_ system call
	. Both these code fragments open the same file:

		// Style 1
		chdir( "/a" );
		chdir( "b" );
		open( "c", O_RDONLY );

		// Style 2
		open( "/a/b/c", O_RDONLY );

		. The first style changes the process's current directory
		  to "/a/b"
		. The second style neither refers to nor changes the
		  process's current directory


	~~~ Creating a new file or directory ~~~

	. There are multiple system calls to create a new file or directory:
		. _mkdir_ creates a new directory
		. _open_ with the O_CREATE flag creates a new data file
		. _mknod_ creates a new device file
	. For example:

		mkdir( "/dir" );

		fd = open( "/dir/file", O_CREATE | O_WRONLY );
		close( fd );

		mknod( "/console", 1, 1 );


	~~~ Mknod ~~~

	. _mknod_ creates a file in the file system but the file has no contents.
	. Instead, the file's metadata marks it as a *device* file and records
	  the major and minor device numbers (the two arguments to mknod) which
	  uniquely identify a kernel device
	. When a process later opens the file, the kernel diverts read and write
	  system calls to the kernel device implementation instead of passing
	  the to the file system


	~~~ Fstat ~~~

	. _fstat_ retrieves information about the object a file descriptor
	  refers to.
	. It fills in a "struct stat" defined in stat.h as:

		#define T_DIR  1   // Directory
		#define T_FILE 2   // File
		#define T_DEV  3   // Device

		struct stat
		{
			short type;   // Type of file
			int   dev;    // File system's disk device
			uint  ino;    // Inode number
			short nlink;  // Number of links to file
			uint  size;   // Size of file in bytes
		};


	~~~ Link, unlink ~~~

	. A file's name is distinct from the file itself.
	  The same underlying file, called an *inode* can have multiple names
	  called *links*

	. _link_ system call creates another file system name referring to
	  the same inode as an existing file.
	. For example, this snippet creates a new file named both "a" and "b":

		open( "a", O_CREATE | O_WRONLY );
		link( "a", "b" );

	. Reading from or writing to "a" is the same as to "b"
	. Each inode is identified by a unique inode number.
	  It is possible to determine that "a" and "b" refer to the same
	  underlying contents by inspecting the result of _fstat_:
	  both will return same inode number and link count (in this case 2).

	. _unlink_ removes a name from the file system
	. The file's inode and the disk space holding its content are
	  only freed when:
		. the file's link count is zero,
		. and no file descriptors refer to it
	. For example:

		unlink( "a" );

		. Leaves the inode and dfile content accessible as "b"

	. A temporary inode that will be cleaned up when the process closes
	  fd or exits can be created as follows:

		fd = open( "/tmp/file.txt", O_CREATE | O_RDWR );
		unlink( "/tmp/file.txt" );

		. By removing link, the file's link count is now zero.
		. The only thing keeping it alive is the file descriptor refering to it


	~~~ ... ~~~

	. Shell commands for file system operations are implemented as
	  user-level programs such as 'mkdir', 'ln', 'rm' etc.
	  This allows anyone to extend the shell with new user commands
	  by just adding a new user-level program??
	. One exception is 'cd' which is built into the shell.
	  cd must change the current working directory of the shell itself.
	  If cd were run as a regular command, then the shell would fork a
	  child process, the child process would run cd, and cd would change
	  the child's working directory, not the shell's.


Real world

	. The Unix system call interfaces has been standardized through the
	  Portable Operating System Interface (POSIX)
	. Xv6 is not POSIX compliant:
		. it misses some system calls e.g. lseek
		. partially implements system calls it does have
		. many more
	. Xv6 is a monolithic kernel
	. Xv6 runs on x86 processors (Intel 80386 or later),
	  and much of it's low-level functionality (ex. process implementation)
	  is x86-specific


---------------------------------------------------------------------------------------------
OS organization
---------------------------------------------------------------------------------------------

Intro

	. A key requirement for an OS is to support several activities at once
	. For example using fork, a process can start a new process.
	. The OS must fulfill three requirements:
		. multiplexing
			. The OS must time-share the resources of the computer among
			  these processes
		. isolation
			. The OS must also arrange for isolation between the processes.
			  That is, if one process has a bug and fails, it shouldn't
			  affect processes that don't depend on it
		. interaction
			. The OS must also facilitate interaction between processes,
			  for example pipelines


Abstracting physical resources

	. We work on the assumption that applications do not trust each other
	  (ex. bugs, malicious) and thus a need for isolation.
	. This is in contrast to a co-operative time sharing approach where
	  each application is well behaved and periodically gives up the
	  processor so that other applications can run
	. To this end, applications are forbidden from directly accessing
	  sensitive hardware resources, and instead the resources are
	  abstracted into services.
	. For example:

		...
		. Applications interact with a file system through
		  'open', 'read', 'write', 'close' system calls
		  instead of reading/writing to raw disk sectors.
		. The OS is the one to manage the disk.

		...
		. Switching hardware processors? among processes,
		  saving and restoring register state as necessary,
		  so that applications are oblivious to time-sharing.
		. For example, CPU still shared even if an application
		  is stuck in an infinite loop

		...
		. Processes use 'exec' to build up their memory image,
		  instead of directly interacting with physical memory.
		. This allows the OS to decide where to place a process in memory.
		  If memory is tight, the OS might even store some of
		  the process's data on disk.

		...
		. Many forms of interaction among Unix processes occur via
		  file descriptors
		. E.g. pipelines, ...


User mode, kernel mode, and system calls

	. Strong isolation...
		. If an application makes a mistake, we don't want the OS to fail
		  Instead, the OS should be able to clean up the failed application
		  and continue running other applications
		. Applications shouldn't be able to modify (or even read) the
		  OS's data structures or instructions

	. Processors provide hardware support for isolation
	. x86 for example has two modes in which it can execute instructions:
	  kernel mode and user mode
	. In kernel mode, the processor is allowed to execute privileged instructions
	  such as reading and writing to IO devices (disk, etc.)
	. If an application in user mode attempts to execute a privileged instruction,
	  then the processor doesn't execute the instruction.
	  Instead it switches to kernel mode so that the software in kernel
	  mode can clean up the application, because it did something it
	  shouldn't be doing

	. Processors provide a special instruction that switches the processor
	  from user mode to kernel mode and enters the kernel at an entry
	  point specified by the kernel
	. In x86, 'int' is used for this

	. Once the processor has switched to kernel mode, the kernel can:
		. validate the arguments of the system call,
		. decide whether the application is allowed to perform the
		  requested operation,
		. and then deny it or execute it.
	. It is important that the kernel sets the entry point for
	  transitions. A malicious application for example could enter
	  the kernel at a point where the validation of arguments is skipped.


Kernel organization

	~~~ Monolithic kernel ~~~

	. Entire operating system resides in the kernel so that all
	  system calls run in kernel mode
	. Entire OS runs with full hardware privilege
	. Ex Linux, Xv6
	. Pro - easy for different parts of the OS to cooperate.
	        For example, might ave a buffer cache that can be shared
	        by both the file system and virtual memory system
	. Con - interfaces between different parts of the OS are often complex??
	. Con - kernel mode errors often cause ... stop working and require reboot


	~~~ Microkernel ~~~

	. To reduce the risk of mistakes in kernel, OS designer can minimize
	  amount of OS code that runs in kernel mode, and execute the bulk
	  of it in user mode - microkernel
	. Ex Minix
	. OS services run as user space processes called 'servers'.
	. The kernel provides an inter-process communication mechanism to
	  send messages from one user-mode process to another...
	. For example, if an application like 'shell' wants to read a file,
	  it sends a message to the 'file server' and waits for a response

	. The kernel interface consists of a few low-level functions for:
		. starting functions
		. sending messages
		. accessing device hardware
		. etc.?
	. In this orginaztion style, most of the OS resides in user-level servers


Process overview

	. In Xv6, the process is the unit of isolation
	. The kernel must implement process abstraction with care because
	  a buggy or malicious application may ...
	. Mechanisms used by the kernel to implement processes include:
		. user/kernel mode flag
		. address spaces
		. time-slicing for threads

	. To help enforce isolation, the process abstraction provides the
	  illusion to a program that it has its own private machine...
	. A process provides a program with what appears to be:
		. a private memory system, or address space?
		. its own CPU


	~~~ Page tables ~~~

	. Xv6 uses page tables (which are implemented by hardware??) to
	  give each process its own address space.
	. The x86 page table translates (maps) a virtual address
	  (the address that a x86 instruction manipualtes) to
	  a physical address (the address the CPU sends to main memory)

	. Xv6 maintains a separate page table for each process that
	  defines the process's address space

	             0xFFFF_FFFF ->  -------------------
	                             memory mapped
	                             IO devices 
	  (DEVSPACE) 0xFE00_0000 ->  -------------------
	                             ...
	                             free memory
	                             ...
	             0x8040_0000 ->  -------------------  <-
	                             kernel rodata          |
	                             -------------------    |
	                             kernel text            |
	             0x8010_0000 ->  -------------------    | kernel
	                             bootloader, ?          |
	  (KERNBASE) 0x8000_0000 ->  -------------------  <-
	                             program data & heap    |
	                             -------------------    |
	              (PAGESIZE)     user stack             | user
	                             -------------------    |
	                             user rodata            |
	                             -------------------    |
	                             user text              |
	             0x0000_0000 ->  -------------------  <-

	. The address space includes the process's user memory
	  starting at virtual address zero
		. instructions come first,
		. followed by global variables,
		. then the stack,
		. then the "heap" area (for malloc) that the process
		  can expand as needed
		. then the kernel's instructions and data

	. A process's page table also serves as the record of the addresses
	  of the physical pages allocated to store the process's memory??


	~~~ ... ~~~

	. The kernel maintains many pieces of state for each process,
	  which it gathers into a 'struct proc'.
	  A process's most important pieces of kernel state are its:
		. page table
		. kernel stack
		. run state

		// Per-process state
		struct proc
		{
			uint              sz;                // Size of process memory (bytes)
			pde_t            *pgdir;             // Page table
			char             *kstack;            // Bottom of kernel stack for this process
			enum procstate    state;             // Process state
			int               pid;               // Process ID
			struct proc      *parent;            // Parent process
			struct trapframe *tf;                // Trap frame for current syscall
			struct context   *context;           // swtch() here to run process
			void             *chan;              // If non-zero, sleeping on chan
			int               killed;            // If non-zero, have been killed
			struct file      *ofile [ NOFILE ];  // Open files
			struct inode     *cwd;               // Current directory
			char              name [ 16 ];       // Process name (debugging)
		};


	. Each process has a thread of execution that executes the process's
	  instructions.
	. A thread can be suspended and later resumed
	. To switch between processes, the kernel suspends the currently
	  running thread and resumes another process's thread

	. Much of the state of a thread (local varialbes, function call return
	  address) is stored on the thread's stacks...
	. Each process has two stacks:
		. user stack
		. kernel stack (p->kstack)
	. When a process is executing user instructions, only its user stack
	  is used. The kernel stack is empty.
	. When the process enters kernel mode (ex. system call or interrupt),
	  the kernel code executes on the process's kernel stack.
	. Because the kernel stack is separate from the user stack, it can
	  execute even if a process has wrecked its user stack

	. When a process makes a system call:
		. the processor switches to the kernel stack,
		. raises the hardware privilege level,
		. and starts executing the kernel instructions that implement the
		  system call
	. When the system call completes, the kernel returns to user space:
		. the hardware lowers privilege level,
		. switches back to the user stack,
		. and resumes executing user instructions just after the
		  system call instruction

	. A process's thread can 'block' in the kernel to wait for IO, and
	  resume were it left off when the IO has finished

	. p->state indicates whether the process is allocated, ready to run,
	  running, waiting for IO, or exiting.

		enum procstate
		{
			UNUSED,
			EMBRYO,
			SLEEPING,
			RUNNABLE,
			RUNNING,
			ZOMBIE
		};

	. p->pgdir holds the process's page table in the format that
	  x86 expects.


The beginning

	. Let's look at how:
		. the kernel creates the first address space (for itself)
		. the kernel creates and starts the first process
		. that process performs the first system call


Creating the first address space

	. The first step in providing strong isolation is setting
	  up the kernel to run in its own address space
	. When a PC powers on, it initializes itself?, and then
	  loads a "boot loader" from disk into memory and executes it
	  starting at "entry" (entry.S)
	. The x86 paging hardware is not enabled when the kernel starts.
	  Virtual addresses map directly to physical addresses.


	~~~ ... ~~~

	. The boot loader loads the Xv6 kernel into memory at
	  physical address 0x0010_0000
	. It does not load the kernel at 0x8010_0000 (where the kernel
	  expects its instructions and data to be) because there may
	  not be any physical memory at that address in a small machine
	. It does not load the kernel at 0x0 because in x86?, the
	  address range 0x000A_0000 .. 0x0010_0000 contains IO devices??
	  https://wiki.osdev.org/Memory_Map_(x86)

	. To allow the rest of? the kernel to run, 'entry' sets up a
	  page table that maps virtual addresses starting at
	  0x8000_0000 (KERNBASE) to physical address starting at 0x0

	  | virtual addr |                  | physical addr |

	  0xFFFF_FFFF ->  ------------------
		              ...
		              ------------------
		              free memory       
	  0x8040_0000 ->  ------------------  <- 0x0040_0000
		              text and data     
	  0x8010_0000 ->  ------------------  <- 0x0010_0000
		              BIOS, ?
	  0x8000_0000 ->  ------------------  <- 0x0000_0000


	. The entry page table is defined in "main.c"

		__attribute__( ( __aligned__( PGSIZE ) ) )
		pde_t entrypgdir [ NPDENTRIES ] = {

			// Map VA's [0, 4MB ) to PA's [0, 4MB )
			[ 0 ]                    = ( 0 ) | PTE_P | PTE_W | PTE_PS,

			// Map VA's [KERNBASE, KERNBASE+4MB ) to PA's [0, 4MB )
			[ KERNBASE >> PDXSHIFT ] = ( 0 ) | PTE_P | PTE_W | PTE_PS,
		};


		/// mmu.h ///

		// Page table/directory entry flags.
		#define PTE_P  0x001   // Present
		#define PTE_W  0x002   // Writeable
		#define PTE_U  0x004   // User
		#define PTE_PS 0x080   // Page Size


	. entry[0]? maps virtual addresses 0 .. 0x0040_0000 to
	  physical addresses 0 .. 0x0040_0000
	. This mapping is required as long as entry is executing
	  at low address, but will eventually be removed

	. entry[512]? maps virtual address KERNBASE .. KERNBASE + 0x0040_0000 to
	  physical addresses 0 .. 0x0040_0000
	. This mapping will be used by the kernel after 'entry'
	  has finished
	. It maps the high virtual address the kernel expects to
	  find its instructions and data to the low physical address
	  where the boot loader loaded them
	. This mapping restricts the kernel instructions and data
	  to 4 Mbytes (0x0040_0000)

		  KERNBASE >> PDXSHIFT
		= 0x80000000 >> 22
		= 512


	~~~ Set page directory ~~~

	. "entry.S" first loads the physical address of "entrypgdir"
	  into the control register (cr3)
	. The symbol 'entrypgdir' refers to an address in high memory.
	  The macro V2P_WO subtracts KERNBASE in order to get the
	  physical address

		/// entry.S ///

		movl  $( V2P_WO( entrypgdir ) ), %eax
		movl  %eax, %cr3


		/// memlayout.h ///

		#define V2P_WO ( x ) ( ( x ) - KERNBASE )


	~~~ Enable paging hardware ~~~

	. To enable paging hardware, Xv6 sets the CR0_PG flag in
	  the control register (cr0)

		movl  %cr0, %eax
		orl   $( CR0_PG | CR0_WP ), %eax
		movl  %eax, %cr0


	~~~ Transfer to kernel's C code and run it in high memory ~~~

	. First makes the stack pointer (esp) point to the memory
	  location to be used as a stack
	. Then jumps to main.
	  An indirect jump is needed because the assembler would
	  otherwise generate a PC-relative direct jump...

		/// entry.S ///

		entry:

			...

			movl $( stack + KSTACKSIZE ), %esp

			mov $main, %eax
			jmp *%eax

		.comm stack, KSTACKSIZE  // allocate space...


		/// param.h ///

		#define KSTACKSIZE 4096  // size of per-process kernel stack


	. Now the kernel is running in high addresses in the
	  function "main" ("main.c")

Creating the first process

	. We will now look at how the kernel creates user-level
	  processes and ensures that they are strongly isolated


	~~~ allocproc, kernel stack ~~~

	. After main initializes several devices and subsytems,
	  it creates the first process by calling "userinit"
	. userinit's first action is to call "allocproc"

	. "allocproc" job is to:
		. allocate a slot (a struct proc) in the process table, and
		. to initialize the parts of the process's state
		  required for its kernel thread to execute ??

	. allocproc is called for each new process, while
	  userinit is called only once for the very first process
	. allocproc is written so that it can also be used by 'fork'

	. allocproc sets up the new process with a specially prepared
	  kernel stack and set of kernel registers that will cause ? to
	  "return" to user space when it first runs

	. allocproc first scans the "proc" table for a slot with state UNUSED 

		for ( p = ptable.proc; p < &ptable.proc[ NPROC ]; p += 1 )
		{
			if ( p->state == UNUSED )
			{
				goto found;
			}
		}

	. When it finds an unused slot, allocproc sets the state to
	  EMBRYO, to mark it as used and gives the process a unique pid

		p->state = EMBRYO;
		p->pid   = nextpid;

		nextpid += 1;

	. Next it tries to allocate a kernel stack for the process's
	  kernel thread.
	. If the memory allocation fails, allocproc changes the
	  state back to UNUSED and return zero to signal failure.

		if( ( p->kstack = kalloc() ) == 0 )
		{
			p->state = UNUSED;

			return 0;
		}

		sp = p->kstack + KSTACKSIZE;


	. Now allocproc must setup the kernel stack to look like this:

	---------------  <-- p->kstack + KSTACKSIZE
	trapframe
	(initialized
	 as if entered
	 kernel via
	 interrupt)
	---------------  <-- p->tf
	trapret
	---------------  <-- address forkret will return to (p->tf - 4)
	context
	(eip = forkret,
	 others 0)
	---------------  <-- p->context
	empty
	...
	---------------  <-- p->kstack


	. It does this as follows:

		/// proc.c ///

		// Leave room for trap frame.
		sp -= sizeof *p->tf;
		p->tf = ( struct trapframe* )sp;

		// Set up new context to start executing at forkret,
		// which returns to trapret.
		sp -= 4;
		*( uint* )sp = ( uint )trapret;

		// Setup register contents that 
		sp -= sizeof *p->context;
		p->context = ( struct context* )sp;

		memset( p->context, 0, sizeof *p->context );

		p->context->eip = ( uint )forkret;


		/// proc.h ///

		struct context
		{
			uint edi;
			uint esi;
			uint ebx;
			uint ebp;
			uint eip;
		};

	. The code sets up program counter return values that will
	  cause the kernel thread to first execute 'forkret'
	  and then 'trapret'
	. The kernel thread will start executing with the
	  register contents (edi, esi, ebx, ebp, eip) in p->context.
	  Since p->context->eip is set to 'forkret', that is where
	  the kernel thread will start executing

		// A fork child's very first scheduling by scheduler()
		// will swtch here.  "Return" to user space.
		void forkret ( void )
		{
			static int first = 1;

			...

			if ( first )
			{
				// Some initialization functions must be run in the context
				// of a regular process ( e.g., they call sleep ), and thus cannot
				// be run from main().
				first = 0;

				iinit( ROOTDEV );

				initlog( ROOTDEV );
			}

			// Return to "caller", actually trapret ( see allocproc ).
		}

	. 'forkret' will return to whatever address is at the
	  bottom of the stack.
	  allocproc has placed the address of 'trapret' here
	. trapret restores user registers from values stored
	  at the top of the kernel stack, and jumps into the process??

		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret

	. The context switch code (swtch.S) sets the stack pointer
	  to point just beyond the end of p->context,
	  where in this case, allocproc has placed the address of trapret
	. Control transfers from user software to the kernel via
	  an interrupt mechanism which is used by system calls,
	  interrupts, and exceptions
	. Whenever control transfers into the kernel while a
	  process is running, the hardware and Xv6 "trap entry code"??
	  save user registers onto the process's kernel stack

		/// x86.h ///

		// Layout of the trap frame built on the stack by the
		// hardware and by trapasm.S, and passed to trap().
		struct trapframe
		{
			// registers as pushed by pusha
			uint edi;
			uint esi;
			uint ebp;
			uint oesp;  // useless & ignored
			uint ebx;
			uint edx;
			uint ecx;
			uint eax;

			// rest of trap frame
			ushort gs;
			ushort padding1;
			ushort fs;
			ushort padding2;
			ushort es;
			ushort padding3;
			ushort ds;
			ushort padding4;
			uint   trapno;

			// below here defined by x86 hardware
			uint   err;
			uint   eip;
			ushort cs;
			ushort padding5;
			uint   eflags;

			// below here only when crossing rings, such as from user to kernel
			uint   esp;
			ushort ss;
			ushort padding6;
		};


		/// trapasm.S ///

		alltraps:

			# Build trap frame.
			pushl   %ds
			pushl   %es
			pushl   %fs
			pushl   %gs
			pushal
			
			# Set up data segments.
			movw    $( SEG_KDATA << 3 ), %ax
			movw    %ax, %ds
			movw    %ax, %es

			# Call trap( tf ), where tf = %esp
			pushl   %esp
			call    trap
			addl    $4, %esp

		# Return falls through to trapret...
		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret


	. after allocproc, 'userinit' writes values to the
	  trapframe at the top of the stack that make it look
	  just like what would be there if the process had entered
	  the kernel via an interrupt.
	. This allows the ordinary code (?) for returning from the
	  kernel back to the process's user code to work.

		memset( p->tf, 0, sizeof( *p->tf ) );

		p->tf->cs     = ( SEG_UCODE << 3 ) | DPL_USER;
		p->tf->ds     = ( SEG_UDATA << 3 ) | DPL_USER;
		p->tf->es     = p->tf->ds;
		p->tf->ss     = p->tf->ds;
		p->tf->eflags = FL_IF;
		p->tf->esp    = PGSIZE;
		p->tf->eip    = 0;  // beginning of initcode.S

		. %cs to contain a segment selector for SEG_UCODE,
		  %ds,es,ss  '''                        SEG_UDATA,
		  all running at user privilege level (DPL_USER)
		. The %eflags bit FL_IF is set to allow hardware interrupts
		. %esp (stack pointer) is set to the process's largest
		  valid virtual address, p->sz??
		. %eip (instruction pointer) is set to the entry point
		  of initcode (address 0)

	. Now the kernel stack is completely prepared
	  (see above diagram)


	~~~ page table, address space ~~~

	. The first process is going to execute a small
	  program (initcode.S)
	. The process needs:
		. physical memory in which to store this program.
		. a page table that maps user-space addresses to
		  that memory

	. userinit calls 'setupkvm' to create a page table for
	  the process

		if ( ( p->pgdir = setupkvm() ) == 0 )
		{
			panic( "userinit: out of memory?" );
		}


	. The initial contents of the first process's user-space
	  memory are the compiled form of 'initcode.S'
	. As part of the kernel build process, the linker embeds
	  the 'initcode' binary in the kernel and defines
	  two special symbols:
		. _binary_initcode_start: indicates location of binary
		. _binary_initcode_size : indicates size of binary in bytes

		https://www.devever.net/~hl/incbin
		https://stackoverflow.com/a/53243725

	. userinit copies the contents of the 'initcode' binary
	  into the new process's memory by calling 'inituvm'
	. inituvm:
		. allocates one page of physical memory,
		. maps virtual address zero to that memory,
		. and copies the binary to that page...


		/// proc.c ///

		inituvm(

			p->pgdir,
			_binary_initcode_start,
			( int )_binary_initcode_size
		);

		p->sz = PGSIZE;


		/// vm.c ///

		// Load the initcode into address 0 of pgdir.
		// sz must be less than a page.
		void inituvm ( pde_t *pgdir, char *init, uint sz )
		{
			char *mem;

			...

			mem = kalloc();

			memset( mem, 0, PGSIZE );

			mappages( pgdir, 0, PGSIZE, V2P( mem ), PTE_W | PTE_U );

			memmove( mem, init, sz );
		}


	~~~ ready ~~~

	. Once the process is initialized, userinit marks it as
	  available for scheduling by setting:

		p->state = RUNNABLE;


Running the first process

	. Now that the first process's state is prepared, it is time
	  to run it

	. After 'main' calls 'userint', it calls 'mpmain'
	. 'mpmain' then calls 'scheduler' to start running the process


	~~~ scheduler ~~~

	. Changing page tables while executing in the kernel works
	  because 'setupkvm' causes all processes' page tables to
	  have identical mappings for kernel code and data

	. scheduler looks for a process with p->state set to RUNNABLE,
	  and there's only one: our first process
	. It sets the per-cpu variable 'proc' to the process it found


	~~~ switchuvm ~~~

	. It then calls 'switchuvm' to tell the hardware to start using the
	  target process's page table

		for ( ;; )
		{
			for ( p = ptable.proc; p < &ptable.proc[ NPROC ]; p += 1 )
			{
				if ( p->state != RUNNABLE )
				{
					continue;
				}

				c->proc = p;

				switchuvm( p );

				...
			}
		}

	. 'switchuvm' also sets up a task state segment? SEG_TSS that
	  instructs the hardware to execute system calls and interrupts
	  on the process's kernel stack??

		// Switch TSS and h/w page table to correspond to process p.
		void switchuvm ( struct proc *p )
		{
			mycpu()->gdt[ SEG_TSS ] = SEG16(

				STS_T32A,                   // type
				&mycpu()->ts,               // base address
				sizeof( mycpu()->ts ) - 1,  // limit
				0                           // descriptor privilege level
			);

			mycpu()->gdt[ SEG_TSS ].s = 0;  // 0 = system, 1 = application

			// ?
			mycpu()->ts.ss0  = SEG_KDATA << 3;
			mycpu()->ts.esp0 = ( uint )p->kstack + KSTACKSIZE;

			// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
			// forbids I/O instructions ( e.g., inb and outb ) from user space
			mycpu()->ts.iomb = ( ushort ) 0xFFFF;

			// ?
			ltr( SEG_TSS << 3 );

			// switch to process's address space
			lcr3( V2P( p->pgdir ) );
		}


	. scheduler now sets p->state to RUNNING and calls 'swtch'
	  to perform a context switch to the target process's kernel thread

		p->state = RUNNING;

		swtch( &( c->scheduler ), p->context );


	~~~ swtch ~~~

	. swtch first saves the current registers.
	. The current context is not a process but rather a special
	  per-cpu scheduler context, so scheduler tells swtch to save
	  the current hardware's registers in per-cpu storage
	  (cpu->scheduler) rather than in any process's kernel thread
	  context.

	. swtch then loads the saved registers of the target kernel
	  thread (p->context)

		swtch:

			movl   4( %esp ), %eax  # eax = old; c->scheduler
			movl   8( %esp ), %edx  # edx = new; p->context

			# Save old callee-saved registers
			pushl  %ebp
			pushl  %ebx
			pushl  %esi
			pushl  %edi

			# Switch stacks
			movl   %esp, ( %eax )  # [old] = esp; update pointer c->scheduler 
			movl   %edx, %esp      #   esp = new; use pointer p->context

			# Load new callee-saved registers
			popl   %edi
			popl   %esi
			popl   %ebx
			popl   %ebp

			ret

	. The final 'ret' instruction pops the target process's
	  'eip' from the stack, finishing the context switch
	. Now the processor is running on the kernel stack of process p


	~~~ forkret ~~~

	. allocproc had previously set initproc's
	  p->context->eip to forkret, so the ret starts executing there
	. On the first invocation (this one), forkret runs initialization
	  functions that cannot be run from main because they must be
	  run in the context of a regular process with its own kernel stack

		// A fork child's very first scheduling by scheduler()
		// will swtch here.  "Return" to user space.
		void forkret ( void )
		{
			static int first = 1;

			...

			if ( first )
			{
				// Some initialization functions must be run in the context
				// of a regular process ( e.g., they call sleep ), and thus cannot
				// be run from main().
				first = 0;

				iinit( ROOTDEV );

				initlog( ROOTDEV );
			}

			// Return to "caller", actually trapret ( see allocproc ).
		}


	~~~ trapret ~~~

	. When allocproc returns, allocproc has arranged for trapret
	  to begin executing
	. trapret uses pop instructions to restore registers from the
	  trap frame just as swtch did with the kernel context

		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret

		. popal restores the general purpose registers
		. addl skips over two fields (trapno and errcode)
		. iret pops %eip, %cs, %flags, %esp, and %ss from the stack
		. see "struct trapframe"

	. The contents of the trap frame hae been transferred to the
	  CPU state, so the processor continues at tf->eip


	~~~ ... ~~~

	. For initproc, tf->eip points to virtual address zero, the
	  first instruction of initcode.S

	. At this point %eip holds zero, %esp holds 4096 ?? TODO

		/// proc.c - userinit ///

		p->tf->esp = PGSIZE;
		p->tf->eip = 0;  // beginning of initcode.S


	. These are virtual addresses in the process's address space
	. The CPU's paging hardware will translate them into physical addresses

	. inituvm has setup the process's page table so that virtual address
	  zero refers to the physical memory allocated for this process
	. It has also seta flag (PTE_U) that tells the paging hardware
	  to allow user code to acess that memory

		void inituvm ( pde_t *pgdir, char *init, uint sz )
		{
			char *mem;

			...

			mem = kalloc();

			memset( mem, 0, PGSIZE );

			mappages( pgdir, 0, PGSIZE, V2P( mem ), PTE_W | PTE_U );

			memmove( mem, init, sz );
		}

	. The fact that userinit has setup the low bits of %cs?
	  to run the process's user code at DPL_USER means that
	  the user code can only use pages with PTE_U set, and cannot
	  modify sensitive hardware registers such as %cr3.
	  The process is constrained to using its own memory.

		p->tf->cs = ( SEG_UCODE << 3 ) | DPL_USER;
		p->tf->ds = ( SEG_UDATA << 3 ) | DPL_USER;


The first system call: exec

	. Let's look at how a user-level process re-enters the kernel
	  to ask for services that it cannot perform itself.


	~~~ initcode.S ~~~

	. The first thing that initcode.S does, is to invoke the
	  exec system call

		# exec( char *path, char *argv[] )
		# exec( init, argv )
		start:

			pushl $argv
			pushl $init
			pushl $0     # where caller pc would be
			movl  $SYS_exec, %eax
			int   $T_SYSCALL

		# char init[] = "/init\0";
		init:

			.string "/init\0"

		# char *argv[] = { init, 0 };
		.p2align 2
		argv:

			.long init
			.long 0


	. It begins by pushing three values on the stack:
		. $argv
		. $init
		. 0
	. Then sets %eax to $SYS_exec
	. Then executes 'int T_SYSCALL'
	  If all goes well, exec never returns


	~~~ exec ~~~

	. exec starts running the program named $init,
	  which is a pointer to a null-terminated string.
	  FYI, this executes /usr/prog/init.c
	. The other argument "argv" is the array of
	  command-line arguments. The zero at the end of the
	  array marks its end.

	. We will cover the details of exec in more detail,
	  but at a high level, it replaces initcode with the
	  /init binary loaded from the file system.


	~~~ init ~~~

	. init creates a new console device file if needed.
	. It then opens the device as file descriptors 0, 1, 2.

		if ( open( "console", O_RDWR ) < 0 )
		{
			mknod( "console", 1, 1 );

			open( "console", O_RDWR );
		}

		dup( 0 );  // stdout
		dup( 0 );  // stderr

	. init then starts a console shell, and
	  handles orphaned zombies until the shell exits ??

		for ( ;; )
		{
			printf( 1, "init: starting sh\n" );

			pid = fork();

			if ( pid < 0 )
			{
				printf( 1, "init: fork failed\n" );
				exit();
			}

			if ( pid == 0 )
			{
				exec( "sh", argv );

				printf( 1, "init: exec sh failed\n" );
				exit();
			}

			// ??
			while ( ( wpid = wait() ) >= 0 && wpid != pid )
			{
				printf( 1, "zombie!\n" );
			}
		}


	. The system is up!


	~~~ Road to startup ~~~


	BIOS -> bootasm.start() -> bootmain() -> entry() -> main()

	main()
	     |--> ...
	     |
	     |--> userinit()
	     |             |--> allocproc()
	     |             |              |--> kalloc()
	     |             |
	     |             |--> setupkvm()
	     |             |            |--> kalloc()
	     |             |            |--> mappages()
	     |             |
	     |             |--> inituvm()
	     |                          |--> kalloc()
	     |                          |--> mappages()
	     |
	     |--> mpmain() -> scheduler() -> swtch() -> forkret() -> trapret() -> initcode.start() -> init.main()


---------------------------------------------------------------------------------------------
Page tables
---------------------------------------------------------------------------------------------

Paging hardware

	. A x86 page table is logically an array of 2^20 page table
	  entries (PTEs)
	. Each PTE contains:
		. a 20bit physical page number (PPN)
	  	. seven flags
	. The paging hardware translates a virtual address by:
		. using its top 20 bits to index into the page table to
		  find a PTE
		. then replacing the virtual address's top 20 bits with
		  the value (PPN) retrieved from the PTE
	. Thus the page table gives the OS control over V2P address
	  translations at the granularity of aligned chunks of
	  4096 bytes. (2^(32-20) = 2^12)
	. Such a chunk is called a page.


	. A page table is stored in physical memory as a two-level tree.
	. The root of the tree is a 4096 byte page directory that
	  contains 1024 PTE-like references to page tables
	. The hardware uses the top 10 bits of the VAaddr to select
	  a page directory entry
	. The next 10 bits of the Vaddr are used to select a PTE
	  from the page table that the page directory refers to
	. This two-level structure allows a page table to omit
	  entire pages?? in he case where large ranges of virtual
	  addresses have no mappings...?

		Virtual address

			31..22 - page directory entry (used to pick a page table)
			21..12 - page table entry     (used to picke a PTE)
			11..0  - offset


		Physical address

			31..12 - PPN
			11..0  - offset


		CR3

			Holds physical base address of page directory ??


		Page directory (points to page tables)

			         -----------
			         PTN | Flags
			1023 ->  -----------
			         ...
			         -----------
			         PTN | Flags
			   1 ->  -----------
			         PTN | Flags
			   0 ->  -----------


		PDE

			31..12 - page table number (PTN)
			11..7  - reserved
			     6 - unused (set to zero)
			     5 - accessed
			     4 - cache disabled
			     3 - 1 = write-through, 0 = write-back
			     2 - user
			     1 - writeable
			     0 - present


		Page table

			         -----------
			         PPN | Flags
			1023 ->  -----------
			         ...
			         -----------
			         PPN | Flags
			   1 ->  -----------
			         PPN | Flags
			   0 ->  -----------


		PTE

			31..12 - physical page number (PPN)
			11..7  - reserved
			     6 - dirty
			     5 - accessed
			     4 - cache disabled
			     3 - 1 = write-through, 0 = write-back
			     2 - user      (PTE_U)
			     1 - writeable (PTE_W)
			     0 - present   (PTE_P)


	. If either the PDE or PTE is not present, the paging
	  hardware raises a fault 

	. Each PTE contains flag bits that tell the paging hardware
	  how the associated virtual address is allowed to be used
	. PTE_P indicates whether the PTE is present.
	  If not set, a reference to the page causes a fault
	. PTE_W controls whether user program is allowd to use the page.
	  If not set, only the kernel is allowd to use the page.


Process address space

	. Each process has a separate page table
	. A process's user memory starts at virtual address zero and
	  can grow up to KERNBASE, allowing a process to address up
	  to 2GB of memory

	. When a process asks Xv6 for more memory, Xv6:
		. first finds free physical pages to provide the storage,
		. then, adds PTE's to the process's page table that point
		  to the new physical pages...
	. Xv6 sets the PTE_U, PTE_W, PTE_P flags in these PTEs
	. Most processes do not used the entire address space.
	  For unused PTEs, the PTE_P flag is clear

	. PHYSTOP??

	. Each process sees its memory as having contiguous virtual
	  addresses whereas the physical memory can be non-contiguous


	. Virtual

	             0xFFFF_FFFF ->  -------------------
	                             memory mapped
	                             IO devices 
	  (DEVSPACE) 0xFE00_0000 ->  -------------------
	                             ...
	                             free memory
	                             ...
	             0x8040_0000 ->  -------------------  <-
	                             kernel rodata          |
	                             -------------------    |
	                             kernel text            |
	             0x8010_0000 ->  -------------------    | kernel
	                             bootloader, ?          |
	  (KERNBASE) 0x8000_0000 ->  -------------------  <-
	                             program data & heap    |
	                             -------------------    |
	              (PAGESIZE)     user stack             | user
	                             -------------------    |
	                             user rodata            |
	                             -------------------    |
	                             user text              |
	             0x0000_0000 ->  -------------------  <-

	. Physical


	             0xFFFF_FFFF ->  -------------------
	                             memory mapped
	                             IO devices 
	             (PHYSTOP) ? ->  -------------------
	                             ...
	                             free memory
	                             ...
	             0x0040_0000 ->  -------------------
	                             kernel rodata
	                             -------------------
	                             kernel text
	    (EXTMEM) 0x0010_0000 ->  -------------------
	                             IO devices
	                       ? ->  -------------------
	                             boot loader (512 bytes)
	             0x0000_7C00 ->  -------------------
	                             ?
	             0x0000_0000 ->  -------------------


Creating an address space

	. main calls 'kvmalloc' to create and switch to a page table
	  with mappings above KERNBASE required for the kernel to run

		// Allocate one page table for the machine for the
		// kernel address space for scheduler processes.
		void kvmalloc ( void )
		{
			kpgdir = setupkvm();

			switchkvm();
		}

	~~~ setupkvm ~~~

	. Most of the work happens in 'setupkvm'
	. It first allocates a page of memory to hold the
	  page directory

		if ( ( pgdir = ( pde_t* )kalloc() ) == 0 )
		{
			return 0;
		}

		memset( pgdir, 0, PGSIZE );


	. It then calls mappages to install?? the translations that
	  the kernel needs, which are describe in 'kmap' array
	. The translation includes:
		. the kernel's instructions and data
		. physical memory up to PHYSTOP??
		. and memory ranges which are actually IO devices
	. setupkvm does not install any mappings for the user memory,
	  this will happen later (inituvm?)

		/// proc.c - kmap ///

		extern char data [];  // defined by kernel.ld

		// This table defines the kernel's mappings, which are
		// present in every process's page table.
		static struct kmap
		{
			void *virt;
			uint  phys_start;
			uint  phys_end;
			int   perm;

		} kmap[] = {

			// I/O space
			{
				( void* )KERNBASE,
				0,
				EXTMEM,
				PTE_W
			},
			// Kernel text + rodata
			{
				( void* )KERNLINK,
				V2P( KERNLINK ),
				V2P( data ),
				0
			},
			// Kernel data + memory
			{
				( void* )data,
				V2P( data ),
				PHYSTOP,
				PTE_W
			},
			// More devices
			{
				( void* )DEVSPACE,
				DEVSPACE,
				0,
				PTE_W
			}
		};


		/// proc.c - setupkvm ///

		for ( k = kmap; k < &kmap[ NELEM( kmap ) ]; k += 1 )
		{
			if (
				mappages(

					pgdir,                        // page directory
					k->virt,                      // virtual address start
					k->phys_end - k->phys_start,  // size
					( uint )k->phys_start,        // physical address start
					k->perm                       // permissions
				) < 0 )
			{
				freevm( pgdir );

				return 0;
			}
		}

		return pgdir;


	~~~ mappages ~~~

	. mappages installs mappings into a page table for a range of
	  virtual address to a corresponding range of physical addresses
	. It does this this separately for each virtual address in the
	  range, at page intervals?
	. For each virtual address to be mapped:
		. it calls 'walkpgdir' to find the address of the PTE
		  for that adddress
		. it then initializes the PTE to hold:
			. the relevant physical page number (PPN)
			. desired permissions (PTE_W, PTE_U)
			. sets PTE_P to mark the PTE as valid

		a    = ( char* )PGROUNDDOWN(   ( uint )va );
		last = ( char* )PGROUNDDOWN( ( ( uint )va ) + size - 1 );

		for ( ;; )
		{
			if ( ( pte = walkpgdir( pgdir, a, 1 ) ) == 0 )
			{
				return - 1;
			}

			if ( *pte & PTE_P )
			{
				panic( "remap" );
			}

			*pte = pa | permissions | PTE_P;

			if ( a == last )
			{
				break;
			}

			a  += PGSIZE;
			pa += PGSIZE;
		}


	~~~ walkpgdir ~~~

	. walkpgdir mimics the actions of the x86 paging hardware
	  as it looks up the PTE for a virtual address
	. It uses the upper 10 bits to find the page directory entry
	. If the PDE is not present, then the required page table
	  has not yet been allocated.
	  If the 'alloc' argument is set, walkpdir allocates it and
	  puts its physical address in the page directory
	. Finally, it uses the next 10 bits of the virtual address
	  to find the address of the PTE in the page table page


		/// vm.c ///

		static pte_t * walkpgdir( pde_t *pgdir, const void *va, int alloc )
		{
			pde_t *pde;
			pte_t *pgtab;

			pde = &pgdir[ PDX( va ) ];  // get pde index from va

			if ( *pde & PTE_P )
			{
				pgtab = ( pte_t* )P2V( PTE_ADDR( *pde ) );
			}
			else
			{
				if( ! alloc || ( pgtab = ( pte_t* )kalloc() ) == 0 )
				{
					return 0;
				}

				// Make sure all those PTE_P bits are zero.
				memset( pgtab, 0, PGSIZE );

				// The permissions here are overly generous, but they can
				// be further restricted by the permissions in the page table
				// entries, if necessary.
				*pde = V2P( pgtab ) | PTE_P | PTE_W | PTE_U;
			}

			return &pgtab[ PTX( va ) ];  // get pte index from va
		}


		/// mmu.h ///

		#define PTXSHIFT   12    // offset of PTX in a linear address
		#define PDXSHIFT   22    // offset of PDX in a linear address

		// page directory index
		#define PDX( va ) ( ( ( uint )( va ) >> PDXSHIFT ) & 0x3FF )

		// page table index
		#define PTX( va ) ( ( ( uint )( va ) >> PTXSHIFT ) & 0x3FF )


Physical memory allocation

	. The kernel must allocate and free physical memory at run-time for:
		. page tables
		. process user memory
		. kernel stacks
		. pipe buffers
	. Xv6 uses the physical memory between the end of the kernel
	  and PHYSTOP for run-time allocation
	. It allocates and frees whole 4096-byte pages at a time

	. It keeps track of which pages are free by threading a
	  linked list through the pages themselves.
	. Allocation consists of removing a page from the linked list
	. Freeing consists of adding the freed page to the list

	. There is a bootstrap problem.
	. All of physical memory must be mapped in order for the
	  alllocator to initialize the free list.
	. But creating a page table with these mappings involves
	  alllocating page-table pages??
	. Xv6 solves this problem by using a separate page allocator
	  during entry??, which allocates memory just after the end
	  of the kernel's data segment??
	. This allocator does not support freeing and is limited by
	  the 4 Mbytes mapping in the entrypgdir??, but that is sufficient
	  to allocate the first kernel page table???


Physical memory allocation - Code

	. The allocator's data structure is a list of physical memory
	  pages that are available for allocation
	. Each free page's list element is a "struct run"

		struct run
		{
			struct run *next;
		};

	. Where does the allocator get the memory to hold that data
	  structure? It stores each free page's run structure in the
	  free page itself.

	. The free list is protected by a spin lock.
	. The list and the lock are wrapped in a struct to make clear
	  the lock protects the fields in the struct...

		struct
		{
			struct spinlock lock;
			int             use_lock;
			struct run     *freelist;

		} kmem;

	. main calls 'kinit1' and 'kinit2' to initialize the allocator

		extern char end [];  // first address after kernel loaded from ELF file

		...

		int main ( void )
		{
			kinit1( end, P2V( 4 * 1024 * 1024 ) );  // phys page allocator
			...
			kinit2( P2V( 4 * 1024 * 1024 ), P2V( PHYSTOP ) );  // must come after startothers()
			...
		}

	. The reason for two calls is that for much of main, one cannot
	  use locks or memory above 4 Mbytes
	. The call to kinit1 sets up for lock-less allocation in the
	  first 4 Mbytes (4 * 1024 * 1024)
	. The call to kinit2 enables locking and arranges for memory to
	  be allocatable

		// Initialization happens in two phases.
		// 1. main() calls kinit1() while still using entrypgdir to place just
		// the pages mapped by entrypgdir on free list.
		// 2. main() calls kinit2() with the rest of the physical pages
		// after installing a full page table that maps them on all cores.
		void kinit1 ( void *vstart, void *vend )
		{
			initlock( &kmem.lock, "kmem" );

			kmem.use_lock = 0;

			freerange( vstart, vend );
		}

		void kinit2 ( void *vstart, void *vend )
		{
			freerange( vstart, vend );

			kmem.use_lock = 1;
		}

	. main ought to determine how much physical memory is available,
	  but this is difficult on x86? Insetead it assumes the machine
	  has PHYSTOP bytes of physical memory, and uses all the memory
	  between the end of the kernel and PHYSTOP

	. kinit1 and kinit2 call 'freerange' to add memory to the free
	  list via per-page calls to 'kfree'
	. A PTE can only refer to a physical address that is aligned on
	  a 4096-byte boundary, so freerange uses PGROUNDUP to ensure
	  that it frees only aligned physical addresses

		void freerange ( void *vstart, void *vend )
		{
			char *p;

			p = ( char* )PGROUNDUP( ( uint )vstart );

			for ( ; p + PGSIZE <= ( char* )vend; p += PGSIZE )
			{
				kfree( p );
			}
		}

	. The allocator sometimes treats addresses as integeres in
	  order to perform arithmetic on them.
	  And sometimes as pointers to read and write memory.
	. This is the main reason that the allocator code is full of
	  C type casts.
	. The other reason is that freeing and allocation inherently
	  change the type of the memory?


	~~~ kfree ~~~

	. The function kfree begins by setting every byte in the
	   memory being freed to the value 1
	. This will cause code that uses memory after freeing it
	  (uses "dangling references") to rad garbage instead of
	  the old valid contents.
	  Hopefully this causes such code to break faster.

		memset( v, 1, PGSIZE );

	. kfree then casts "v" to a pointer to "struct run",
	  records the old start of the free list in "r->next",
	  and sets the free list equal to r

		r = ( struct run* )v;

		r->next = kmem.freelist;

		kmem.freelist = r;


	~~~ kalloc ~~~

	. kalloc removes and returns the first element in the
	  free list.

		char* kalloc ( void )
		{
			struct run *r;

			r = kmem.freelist;

			if ( r )
			{
				kmem.freelist = r->next;
			}

			return ( char* )r;
		}


Use part of an address space

	  (KERNBASE) 0x8000_0000 ->  -------------------
	                             heap
	                             -------------------
	              (PAGESIZE)     stack
	                             -------------------
	                             guard page
	                             -------------------
	                             rodata
	                             -------------------
	                             text
	             0x0000_0000 ->  -------------------

	. Each user process starts at address zero
	. The bottom of the address space contains the text for
	  the user program, its data, and its stack.
	. The heap is above the stack so that the heap can expand
	  when the process calls 'sbrk'

	. The stack is a single page (4096 bytes)
	. To guard a stack from growing beyond this size, a
	  guard page is placed right below the stack. The page is not
	  mapped and so if the stack overflows, the hardware will
	  generate an exception.
	. A real-world OS might instead allocate more space for the
	  stack so that it can grow beyond one page


sbrk

	. 'sbrk' is the system call for a process to shrink or grow
	  its memory - sbrk( nBytes )
	. It is implemented by the function 'growproc'

		int sys_sbrk ( void )
		{
			int addr;
			int n;

			...

			addr = myproc()->sz;

			if ( growproc( n ) < 0 )
			{
				return - 1;
			}

			return addr;
		}


	~~~ growproc ~~~

	. If nBytes is positive, growproc allocates one or more
	  physical pages and maps them at the top of the process's
	  address space
	. If nBytes is negative, growproc unmaps one or more
	  pages from the process's address space and frees the
	  corresponding physical pages.
	. To make these changes, Xv6 modifies the process's page
	  table via 'allocuvm' and 'deallocuvm'

		int growproc ( int n )
		{
			uint sz;
			struct proc *curproc = myproc();

			sz = curproc->sz;

			if( n > 0 )
			{
				if( ( sz = allocuvm( curproc->pgdir, sz, sz + n ) ) == 0 )
				{
					return - 1;
				}
			}
			else if( n < 0 )
			{
				if( ( sz = deallocuvm( curproc->pgdir, sz, sz + n ) ) == 0 )
				{
					return - 1;
				}
			}

			curproc->sz = sz;

			switchuvm( curproc );

			return 0;
		}


	. The x86 hardware caches page tables entries in a
	  Translation Look-aside Buffer (TLB), and when Xv6 changes
	  the page tables, it must invalidate the cached entries
	. Xv6 invalidates stale cached entries by reloading cr3 (swithcuvm),
	  the register that holds the address of the current page table


exec

	. exec is the system call that creats the user part of an
	  address space
	. it initializes the user part of an address space from
	  a file stored in the filesystem

	. exec opens the named binary path using 'namei'

		struct elfhdr  elf;
		struct inode  *ip;

		...

		ip = namei( path )


	. Then it reads the ELF header

		if ( readi( ip, ( char* )&elf, 0, sizeof( elf ) ) != sizeof( elf ) )
		{
			goto bad;
		}


	. An ELF binary consists of:
		. an ELF header - "struct elfhdr"
		. followed by a sequence of program section headers - "stuct proghdr"
	. Each 'proghdr' describes a section of the application that
	  must be loaded into memory
	. Xv6 programs have only one ph, but other systems might have
	  separate sections for instructions and data

		struct elfhdr
		{
			uint   magic;       // must equal ELF_MAGIC

			uchar  elf [ 12 ];  // 1 - 32bit, 2 - 64bit
			                    // 1 - little endian, 2 - big endian
			                    // ...
			                    // target OS e.g. System V, Linux
			                    // ...

			ushort type;        // object file type e.g. EXEC, DYN
			ushort machine;     // ISA e.g. x86, MIPS, ARM, RISC-V
			uint   version;     // ...

			uint   entry;       // entry point where process starts executing
			uint   phoff;       // points to start of program header table
			uint   shoff;       // points to start of section header table

			uint   flags;       // ...

			ushort ehsize;      // size of this elf header

			ushort phentsize;   // size of program header entry
			ushort phnum;       // number of entries in program header table

			ushort shentsize;   // size of section header entry
			ushort shnum;       // number of entries in section header table
			ushort shstrndx;    // index of the section	header table entry that contains the section names
		};

		struct proghdr
		{
			uint type;    // type of segment e.g. LOAD, DYNAMIC
			uint off;     // offset of the segment in the file image
			uint vaddr;   // virtual address of the segment in memory
			uint paddr;   // physical address of the segment in memory 
			uint filesz;  // size in bytes of the segment in the file image
			uint memsz;   // size in bytes of the segment in memory
			uint flags;   // ...
			uint align;   // 0 or 1 no alignment
		};

	. It then makes a quick check that the file probably contains an
	  ELF binary.
	. An ELF binary starts with the four-byte magic number:

		#define ELF_MAGIC 0x464C457F  // 0x7F 'E' 'L' 'F' in little endian

	. If the ELF header has the right magic number, exec assumes the
	  binary is well-formed

		if ( elf.magic != ELF_MAGIC )
		{
			goto bad;
		}


	. exec allocates a new page table with no user mappings using
	  setupkvm

		pgdir = setupkvm()


	. exec then allocates memory for each ELF segment with 'allocuvm',
	  and loads each segment into memory with 'loaduvm'

		sz = 0;

		for ( i = 0, off = elf.phoff; i < elf.phnum; i += 1, off += sizeof( ph ) )
		{
			readi( ip, ( char* )&ph, off, sizeof( ph ) )

			...

			sz = allocuvm( pgdir, sz, ph.vaddr + ph.memsz )

			...

			loaduvm( pgdir, ( char* )ph.vaddr, ip, ph.off, ph.filesz )

			...
		}


	. The program section header's filesz might be less than memsz
	  indicating that the gap between them should be filled with
	  zeros rather than read from the file.
	. For example, in _init, filesz is 15 bytes less than memsz


	. readelf -a _init

		ELF Header:
		  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
		  Class:                             ELF32
		  Data:                              2's complement, little endian
		  Version:                           1 (current)
		  OS/ABI:                            UNIX - System V
		  ABI Version:                       0
		  Type:                              EXEC (Executable file)
		  Machine:                           Intel 80386
		  Version:                           0x1
		  Entry point address:               0x0
		  Start of program headers:          52 (bytes into file)
		  Start of section headers:          7684 (bytes into file)
		  Flags:                             0x0
		  Size of this header:               52 (bytes)
		  Size of program headers:           32 (bytes)
		  Number of program headers:         2
		  Size of section headers:           40 (bytes)
		  Number of section headers:         15
		  Section header string table index: 12

		...

		Program Headers:
		  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
		  LOAD           0x000074 0x00000000 0x00000000 0x00b7d 0x00b8c RWE 0x4
		  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10

		...

	. ph would look like,

		ph->type   = ELF_PROG_LOAD
		ph->off    = 0x00000074
		ph->vaddr  = 0x00000000
		ph->paddr  = 0x00000000
		ph->filesz = 0x00000b7d
		ph->memsz  = 0x00000b8c
		ph->flags  = ELF_PROG_FLAG_READ | ELF_PROG_FLAG_WRITE | ELF_PROG_FLAG_EXEC
		ph->align  = 4


	~~~ loaduvm ~~~

	. loaduvm uses walkpgdir to find the physical address of
	  the allocated memory at which to write each page of the
	  ELF segment...
	. loaduvm uses readi to read from the file...

		int loaduvm ( pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz )
		{
			uint   i, pa, n;
			pte_t *pte;

			...

			for ( i = 0; i < sz; i += PGSIZE )
			{
				if ( ( pte = walkpgdir( pgdir, addr + i, 0 ) ) == 0 )
				{
					panic( "loaduvm: address should exist" );
				}

				pa = PTE_ADDR( *pte );

				if ( sz - i < PGSIZE )
				{
					n = sz - i;
				}
				else
				{
					n = PGSIZE;
				}

				if ( readi( ip, P2V( pa ), offset + i, n ) != n )
				{
					return - 1;
				}
			}

			return 0;
		}


	~~~ exec ~~~

	. Now exec allocates and initializes the user stack

	. It allocates just one stack page.

	. exec places an inaccessible page just below the stack page,
	  so that programs that stack overflow will fault
	. This inaccessible page allows Xv6 to deal with arguments
	  that are too large.
	  In that situation, the 'copyout' function that exec uses
	  to copy arguments to the stack will notice that the
	  destination page is not accessible and return -1

		/// exec.c ///

		// Allocate two pages at the next page boundary.
		// Make the first inaccessible. Use the second as the user stack.
		sz = PGROUNDUP( sz );

		if ( ( sz = allocuvm( pgdir, sz, sz + 2 * PGSIZE ) ) == 0 )
		{
			goto bad;
		}

		clearpteu( pgdir, ( char* )( sz - 2 * PGSIZE ) );

		sp = sz;


		/// vm.c ////

		// Clear PTE_U on a page. Used to create an inaccessible
		// page beneath the user stack.
		void clearpteu ( pde_t *pgdir, char *uva )
		{
			pte_t *pte;

			pte = walkpgdir( pgdir, uva, 0 );

			...

			*pte &= ~ PTE_U;
		}


	. exec copies the argument strings to the top of the stack,
	  one at a time, recording the pointers to them in 'ustack'
	. It places a null pointer at the end of what will be the
	  argv list passed to main?
	. The first three entries in ustack are:
		. the fake return PC
		. argc
		. argv pointer

	. TODO: not sure about push order...
	. Ex. exec( "/init\0", [ "/init\0", 0 ] )  ??

	       ---->  ---------------
	      |       0
	stack |       't'
	      |       'i'
	      |       'n'
	      |       'i'
	      |       '/'              argv[0]
	      |       ---------------
	      |       x                argv[1] if existed
	      |       ---------------
	      |       x                argv[2] if existed
	      |   ->  ---------------
	      |  |    0                end of arguments
	'ustack' |    ---------------
	      |  |    x                argv[2] pointer if existed ...
	      |  |    ---------------
	      |  |    x                argv[1] pointer if existed ...
	      |  |    ---------------
	      |  |    argv[0] pointer  ...
	      |  |    ---------------
	      |  |    ??               argv pointer?
	      |  |    ---------------
	      |  |    1                argc
	      |  |    ---------------
	      |  |    0xffffffff       fake return PC
	      |   ->  ---------------
	      |       ...
	       ---->  ---------------


	/// exec.c ///

		// Push argument strings, prepare rest of stack in ustack.
		for ( argc = 0; argv[ argc ]; argc += 1 )
		{
			...

			// ? why & ~ 3? multiples of 4?
			sp = ( sp - ( strlen( argv[ argc ] ) + 1 ) ) & ~ 3;

			copyout(

				pgdir,
				sp,
				argv[ argc ],
				strlen( argv[ argc ] ) + 1
			)

			ustack[ 3 + argc ] = sp;
		}

		ustack[ 3 + argc ] = 0;  // mark end of arguments

		ustack[ 0 ] = 0xffffffff;             // fake return PC
		ustack[ 1 ] = argc;
		ustack[ 2 ] = sp - ( argc + 1 ) * 4;  // argv pointer

		sp -= ( 3 + argc + 1 ) * 4;

		copyout(

			pgdir,
			sp,
			ustack,
			( 3 + argc + 1 ) * 4
		)


	/// vm.c ///

	int copyout ( pde_t *pgdir, uint va, void *p, uint len )
	{
		char *buf, *pa0;
		uint  n, va0;

		buf = ( char* )p;

		while ( len > 0 )
		{
			va0 = ( uint )PGROUNDDOWN( va );

			pa0 = uva2ka( pgdir, ( char* )va0 );

			...

			n = PGSIZE - ( va - va0 );

			...

			memmove( pa0 + ( va - va0 ), buf, n );

			len -= n;
			buf += n;

			va = va0 + PGSIZE;
		}

		...
	}


	. exec must wait to free the old image until it is sure the
	  system call will succeed. If the old image is gone, the
	  system call cannot return -1 to it.

	. once the image is complete, exec can install the
	  new image and free the old one

		oldpgdir = curproc->pgdir;

		curproc->pgdir   = pgdir;
		curproc->sz      = sz;
		curproc->tf->eip = elf.entry;  // main
		curproc->tf->esp = sp;

		switchuvm( curproc );

		freevm( oldpgdir );


	~~~ security ~~~

	. exec loads bytes from the ELF file into memory at addresse
	  specified by the ELF file
	. Users or processes can place whatever addresses they want
	  int an ELF file.
	. Thus exec is risky because the addresses in the ELF file
	  can refer to the kernel, accidentally or on purpose
	. Xv6 performs a number of checks to avoid these risks, but
	  it is likely it does not do a complete job


Real world

	. Xv6 doesn't implement:
		. stuff don't care about
		. automatically extending stacks
	. A "real" kernel alllocator would need to handle both
	  small and large allocations. Xv6 just does one size
	  for all.


---------------------------------------------------------------------------------------------
Traps, interrupts, and drivers
---------------------------------------------------------------------------------------------

System calls, exceptions, and interrupts

	. Three cases where control must be transferred from a user
	  program to the kernel:
		. system call
		. exception (ex divide by zero, attempting to access
		  memory for a PTE that is not present)
		. interrupt
	. The kernel handles all interrupts rather than user processes
	  because in most cases, only the kernel has the required
	  privilege

	. The OS must arrange for the following to happen:
		. save processor's registers
		. setup for execution in kernel
		. choose a place for the kernel to start executing
		. the kernel must be able to retrieve information about
		  the event e.g. system call arguments

	. An interrupt stops the normal processor loop and starts
	  executing a new sequence called an interrupt handler
	. Before starting the interrupt handler, the processor saves
	  its registers, so that the OS can restore them when it
	  returns from the interrupt


x86 protection

	. x86 has four protection levels, numbered 0 (most privilege)
	  to 3 (least)
	. In practice, most OSs use only 0 (kernel) and 3 (user)
	. The current privilege level (CPL) by which the processor
	  executes instructions is stored in %cs register

	. x86 interrupt handlers are defined in the interrupt
	  descriptor table (IDT)
	. The IDT has 256 entries, each giving the %cs and %eip to
	  be used when handling the corresponding interrupt

	. To make a system call, a program invokes the "int n"
	  instruction, where n specifies the index into the IDT
	. The int instruction performs the following steps:

		. fetch the n'th descriptor from the IDT
		. check that CPL is <= DPL (privilege level in the
		  interrupt descriptor)
		. save %esp and %ss in CPU-internal registers, but only
		  if the target segment selector's PL < CPL
		. load %ss and %esp from a task segment descriptor
		. push %ss
		. push %esp
		. push %eflags
		. push %cs
		. push %eip
		. clear the IF bit in %eflags, but only on an interrupt
		. set %cs and %eip to the values in the descriptor

	. The check, CPL <= DPL allows the kernel to forbid
	  int calls to inappropriate IDT entries
	. For example if a user program tries calling a
	  forbidden interrupt, for example of an IO device,
	  it will fail because the interrupt
	  descriptor would have a DPL of 0 (kernel).
	. The int instead is treated as "int 13" which is a
	  general protection fault

	. The int instruction cannot use the user stack to save values,
	  becaue the process may not have a valid stack pointer.
	  Instead, the hardware uses the stack specified in the
	  task segment, which is set by the kernel??

	. Kernel stack after an int instruction

		sp from task ->  -----------  <-
		segment          ss             |
		                 -----------    | only present on
		                 esp            | privilege change
		                 -----------  <-
		                 eflags
		                 -----------
		                 cs
		                 -----------
		                 eip
		                 -----------
		                 error code
		         esp ->  -----------
		                 ...
		                 -----------


	. %eip is pointing to the address specified in the descriptor
	. The instruction at that address is the next instruction
	  to be executed, and the first instruction of the handler for
	  int n.

	. An OS can use the 'iret' instruction to return from an
	  'int' instruction.
	. iret pops the saved values by int from the stack, and resumes
	  execution at the saved %eip


The first system call

	. Previously, we ended with initcode.S invoking a system
	  call 'exec'
	. The process pushed the arguments for an exec call on the
	  processor's stack, and put the system call number in %eax

		start:

			pushl $argv
			pushl $init
			pushl $0     # where caller pc would be
			movl  $SYS_exec, %eax
			int   $T_SYSCALL

	. The system call numbers match the entries in the syscalls
	  array, a table of function pointers

		/// syscall.h ///

		// System call numbers
		#define SYS_fork     1
		#define SYS_exit     2
		#define SYS_wait     3
		#define SYS_pipe     4
		#define SYS_read     5
		#define SYS_kill     6
		#define SYS_exec     7
		#define SYS_fstat    8
		#define SYS_chdir    9
		#define SYS_dup     10
		#define SYS_getpid  11
		#define SYS_sbrk    12
		#define SYS_sleep   13
		#define SYS_uptime  14
		#define SYS_open    15
		#define SYS_write   16
		#define SYS_mknod   17
		#define SYS_unlink  18
		#define SYS_link    19
		#define SYS_mkdir   20
		#define SYS_close   21


		/// syscall.c ///
		static int ( *syscalls[] )( void ) = {

			[ SYS_fork   ] sys_fork,
			[ SYS_exit   ] sys_exit,
			[ SYS_wait   ] sys_wait,
			[ SYS_pipe   ] sys_pipe,
			[ SYS_read   ] sys_read,
			[ SYS_kill   ] sys_kill,
			[ SYS_exec   ] sys_exec,
			[ SYS_fstat  ] sys_fstat,
			[ SYS_chdir  ] sys_chdir,
			[ SYS_dup    ] sys_dup,
			[ SYS_getpid ] sys_getpid,
			[ SYS_sbrk   ] sys_sbrk,
			[ SYS_sleep  ] sys_sleep,
			[ SYS_uptime ] sys_uptime,
			[ SYS_open   ] sys_open,
			[ SYS_write  ] sys_write,
			[ SYS_mknod  ] sys_mknod,
			[ SYS_unlink ] sys_unlink,
			[ SYS_link   ] sys_link,
			[ SYS_mkdir  ] sys_mkdir,
			[ SYS_close  ] sys_close,
		};


	. We need to arrange that:
		. the int instruction switches the processor from user
		  to kernel mode
		. that the kernel invokes the right kernel function
		  (ex. sys_exec)
		. that the kernel can retrieve the arguments for the syscall


Assembly trap handlers

	. Xv6 must setup the x86 hardware to do something sensible
	  when it encounters an int instruction, which causes the
	  processor to generate a trap
	. x86 allows for 256 different interrupts:
		. 0-31 are defined for software exceptions
	. Xv6 maps 32 hardware interrupts to the range 32-63
	. Xv6 uses interrupt 64 as the system call interrupt

		#define T_DIVIDE      0  // divide error
		#define T_DEBUG       1  // debug exception
		#define T_NMI         2  // non-maskable interrupt
		#define T_BRKPT       3  // breakpoint
		#define T_OFLOW       4  // overflow
		#define T_BOUND       5  // bounds check
		#define T_ILLOP       6  // illegal opcode
		#define T_DEVICE      7  // device not available
		#define T_DBLFLT      8  // double fault
		// #define T_COPROC   9  // reserved (not used since 486)
		#define T_TSS        10  // invalid task switch segment
		#define T_SEGNP      11  // segment not present
		#define T_STACK      12  // stack exception
		#define T_GPFLT      13  // general protection fault
		#define T_PGFLT      14  // page fault
		// #define T_RES     15  // reserved
		#define T_FPERR      16  // floating point error
		#define T_ALIGN      17  // aligment check
		#define T_MCHK       18  // machine check
		#define T_SIMDERR    19  // SIMD floating point error

		// These are arbitrarily chosen, but with care not to overlap
		// processor defined exceptions or interrupt vectors.
		#define T_SYSCALL     64  // system call
		#define T_DEFAULT    500  // catchall

		#define T_IRQ0        32  // IRQ 0 corresponds to int T_IRQ


	~~~ tvinit ~~~

	. tvinit sets up the 256 entries in the table "idt"
	. Interrupt "i" is handled by the code at the address in
	  "vectors[i]"
	. tvint handles T_SYSCALL specially: it specifies the gate
	  is of type "trap" by passing a value of 1 as the second
	  argument to SETGATE.
	  Trap gates do not clear the IF flag, allowing other interrupts
	  to occur during the system call handler
	. tvinit also sets the system call gate privilege to DPL_USER

		struct gatedesc idt     [ 256 ];
		extern uint     vectors [];  // in vectors.S: array of 256 entry pointers

		void tvinit ( void )
		{
			int i;

			for ( i = 0; i < 256; i += 1 )
			{
				SETGATE( idt[ i ], 0, SEG_KCODE << 3, vectors[ i ], 0 );
			}

			// If system call, do not disable interrupts.
			// Also set privilege level to DPL_USER.
			SETGATE( idt[ T_SYSCALL ], 1, SEG_KCODE << 3, vectors[ T_SYSCALL ], DPL_USER );

			initlock( &tickslock, "time" );
		}

	. When changing protection levels, the kernel shouldn't use
	  the stack of the user's process because it may not be valid.
	  The user process may be malicious or contain an error that
	  causes %esp to contain an address that is not part of it's
	  user memory??
	. Xv6 programs the x86 hardware to perform a stack switch on
	  a trap by setting up a task segment descriptor through
	  which the hardware loads a stack segment selector and a new
	  value for %esp

	. The function switchuvm stores the address? at the top
	  of the kernel stack of the user process into the
	  task segment descriptor??

		// ?
		mycpu()->ts.ss0  = SEG_KDATA << 3;
		mycpu()->ts.esp0 = ( uint )p->kstack + KSTACKSIZE;


	. When a trap occurs, if it was executing in user mode,
	  the x86 processor:
		. loads %esp and %ss from the task segment descriptor,
		. and pushes the old user %esp and %ss onto the new stack

	. x86 then pushes the %eflags, %cs, and %eip registers
	. For some traps (ex page fault), x86 also pushes an error
	  number

	. x86 then loads %eip and %cs from the relevant IDT entry

	. Kernel stack after an int instruction

		sp from task ->  -----------  <-
		segment          ss             |
		(cpu->ts.esp0)   -----------    | only present on
		                 esp            | privilege change
		                 -----------  <-
		                 eflags
		                 -----------
		                 cs
		                 -----------
		                 eip
		                 -----------
		                 error code
		         esp ->  -----------
		                 ...
		                 -----------


	~~~ vectors.pl ~~~

	. Xv6 uses a Perl script (vectors.pl) to generate the
	  entry points that the IDT entries point to (vectors.S)
	. Each entry:
		. pushes an error code (0) if the processor didn't
		. pushes the interrupt(trap) number,
		. then jumps to 'alltraps'

		/// vectors.S ///

		.globl vector0
		vector0:
			pushl $0
			pushl $0
			jmp alltraps

		...

		.globl vector8
		vector8:
			pushl $8
			jmp alltraps

		...

		.data

			.globl vectors
			vectors:

				.long vector0
				.long vector1
				...
				.long vector255


	~~~ alltraps ~~~

	. 'alltraps' continues to save processor registers.
	. It pushes %ds, %es, %fs, %gs, and the general purpose regs

		alltraps:

			# Build trap frame.
			pushl   %ds
			pushl   %es
			pushl   %fs
			pushl   %gs
			pushal

			...

	. The result of this effort is that the kernel now contains
	  a "struct trapframe" containing the processor's registers
	  at the time of the trap

	. Kernel stack looks like this now:

	         ->  sp from task  ->  -----------  <-                 <-
	        |    segment           ss             | only present     |
	        |   (cpu->ts.esp0)     -----------    | on privilege     |
	        |                      esp            | change           |
	        |                      -----------  <-                   |
	        |                      eflags                            | pushed
	        |                      -----------                       | by x86
	        |                      cs                                |
	        |                      -----------                       |
	        |                      eip                               |
	        |                      -----------                       |
	   trap |                      error code   <- can be pushed     |
	  frame |                                      by trap vector    |
	        |                      -----------  <--------------------
	        |
	        |                      trapno       <--------------------  pushed by
	        |                                                          trap vector
	        |                      -----------  <--------------------
	        |                      ds                                |
	        |                      -----------                       |
	        |                      es                                |
	        |                      -----------                       |
	        |                      fs                                |
	        |                      -----------                       |
	        |                      gs                                |
	        |                      -----------                       |
	        |                      eax                               |
	        |                      -----------                       | pushed by
	        |                      ecx                               | alltraps
	        |                      -----------                       |
	        |                      edx                               |
	        |                      -----------                       |
	        |                      ebx                               |
	        |                      -----------                       |
	        |                      o_esp                             |
	        |                      -----------                       |
	        |                      ebp                               |
	        |                      -----------                       |
	        |                      esi                               |
	        |                      -----------                       |
	        |                      edi                               |
	         ->            esp ->  -----------  <--------------------
	                               ...
	                 p->kstack ->  -----------


	. The trap frame contains all the information necessary
	  to restore the user mode processor registers when the
	  kernel returns to the current process

	. For our case study, the %eax saved holds the system call
	  number (SYS_exec) for the kernel to inspect later

	. With the registers saved, alltraps can finish setting
	  up the processor to run kernel C code
	. Since the x86 processor sets the %cs and %ss before
	  entering the handler, alltraps sets %ds and %es

		# Set up data segments.
		movw  $( SEG_KDATA << 3 ), %ax
		movw  %ax, %ds
		movw  %ax, %es

	. Once the segments are set properly, alltraps can
	  call the C trap handler 'trap'
	. It pushes %esp (which points to the trapframe it just
	  created) onto the stack as an argument to trap
	. Then it calls trap

		# Call trap( tf ), where tf = %esp
		pushl  %esp
		call   trap
		addl   $4, %esp

	. After trap returns, alltraps pops the argument
	  off the stack by adding to the stack pointer
	. alltraps then starts executing the code at label
	  "trapret" which restors user mode registers and
	  then iret jumps back into user space

		trapret:

			popal
			popl   %gs
			popl   %fs
			popl   %es
			popl   %ds
			addl   $0x8, %esp  # trapno and errcode
			iret


	~~~ kernel mode traps ~~~

	. Traps can occur while the kernel is executing
	. In this case, x86 does not:
		. switch stacks...
		. save the stack pointer (%esp)...
		. save the stack segment selector (%ss)...
	. Otherwise, the same steps occur as in traps from user mode
	. When iret later restores a kernel mode %cs,
	  x86 continues executing in kernel mode?


C trap handler

	. 'trap' looks at the hardware trap number tf->trapno
	  to decide why it has been called and what needs to be done
	. If the trap is T_SYSCALL, 'trap' calls the system call
	  handler, 'syscall'

		if ( tf->trapno == T_SYSCALL )
		{
			...

			myproc()->tf = tf;

			syscall();

			...

			return;
		}


	. After checking for a system call, 'trap' looks for
	  hardware interrupts
	. spurious?

	. If the trap is not a system call, and not a hardware
	  interrupt, trap assumes it was caused by incorrect
	  behaviour (ex. divide by zero) as part of the code that
	  was executing before the trap.
	. If the code that caused the trap was a user program,
	  Xv6 prints details and then sets proc->killed to remember
	  to clean up the user process
	. If t was the kernel running, there must be a bug in the
	  kernel. Trap prints details about the surprise and then
	  calls 'panic'

		switch ( tf->trapno )
		{
			case T_IRQ0 + IRQ_TIMER:

				...

			case T_IRQ0 + IRQ_IDE:

				...

			case T_IRQ0 + IRQ_KBD:

				...

			case T_IRQ0 + IRQ_COM1:

				...

			case T_IRQ0 + 7:
			case T_IRQ0 + IRQ_SPURIOUS:

				...

			default:

				if ( myproc() == 0 || ( tf->cs & 3 ) == 0 )
				{
					// In kernel, it must be our mistake.
					cprintf(

						"unexpected trap %d from cpu %d eip %x ( cr2=0x%x )\n",
						tf->trapno, cpuid(), tf->eip, rcr2()
					);

					panic( "trap" );
				}

				// In user space, assume process misbehaved.
				cprintf(

					"pid %d %s: trap %d err %d on cpu %d\n"
					"eip: 0x%x addr: 0x%x --kill proc\n",
					myproc()->pid, myproc()->name,
					tf->trapno, tf->err, cpuid(),
					tf->eip, rcr2()
				);

				myproc()->killed = 1;
		}


System calls

	. For traps, 'trap' invokes 'syscall'
	. syscall loads the system call number from the trap frame,
	  which contains the saved %eax
	. syscall then indexes into the system call table
	  and invokes the appropriate entry

		void syscall ( void )
		{
			int          num;
			struct proc *curproc = myproc();

			num = curproc->tf->eax;

			curproc->tf->eax = syscalls[ num ]();

			...
		}


	. syscall record the reurn value of the system call function
	  in %eax
	. When the trap returns to user space, it will load the
	  values from curproc->tf into the machine registers.
	. Thus when exec returns, it will return the value that
	  the system call handler returned
	. Convention for syscall return values:
		. negative numbers for errors
		. positive numbers for succcess


	~~~ Finding syscall arguments ~~~

	. Helper functions 'argint', 'argptr', 'argstr', and
	  'argfd' retrieve the n'th system call argument as either
	  an integer, pointer, a string, or a file descriptor

	. argint uses the user-space %esp register to locate the
	  n'th argument
	. %esp points at the return address
	. The arguments are right above it at %esp + 4
	. Thus the n'th argument is at ( %esp + 4 ) + 4 * n

		int argint ( int n, int *iptr )
		{
			return fetchint( ( myproc()->tf->esp ) + 4 + ( 4 * n ), iptr );
		}


	. argint calls 'fetchint' to read the balue at that
	  address from user memory and write it to "*iptr"
	. fetchint can simply cast the address to a pointer
	  because the user and kernel share the same page table.
	  However, the kernel must verify that the address lies
	  within the user part of the adderess space.

		int fetchint ( uint addr, int *ip )
		{
			struct proc *curproc = myproc();

			if ( addr >= curproc->sz || addr + 4 > curproc->sz )
			{
				return - 1;
			}

			*ip = *( int* )( addr );

			return 0;
		}


	. argptr fetches the nth system call argument and checks
	  that this argument is a valid user-space pointer
	. argstr interprets the nth argument as a pointer.
	. argfd uses argint to retrieve a file descriptor number,
	  checks if it is a valid file descriptor, and returns the
	  corresponding "struct file"

	. The system call implementations (sysproc.c and sysfile.c)
	  are typically wrappers.
	. They decode the arguments using the helper functions, and
	  then call the real implementations


Interrupts

	. Let's look at the timer device and timer interrupts.
	. We would like the timer to generate an interrupt say
	  100 times per second

	. Early computers had a simple programmable interrupt
	  controller (PIC)
	. With the advent of multiprocessor PC boards, a new way of
	  handling interrupts was needed...
	. This new approach consists of two parts:
		. IOAPIC     - (ioapic.c) attached to the IO system...
		. local APIC - (lapic.c)  attached to each processor...
	. Xv6 is designed for a board with multiple processors. It
	  ignores interrupts from the PIC, and instead configures the
	  IOAPIC and LAPIC

	. The IOAPIC has a table and the processor can program entries
	  in the table through memory-mapped IO
	. During initializtion, 'ioapicinit':
		. disables all interrupts, and
		. maps interrupt 0 to IRQ0 and so on

		void ioapicinit ( void )
		{
			...

			for ( i = 0; i <= maxintr; i += 1 )
			{
				ioapicwrite( REG_TABLE + 2 * i, INT_DISABLED | ( T_IRQ0 + i ) );

				...
			}
		}


	. Specific devices later enable particular interrupts and
	  specify to whch processor the interrupt should be routed to
	. For example, Xv6 routes keyboard interrupts to cpu0,
	  and disk interrupts to the highest numbered processor
	  on the system

		/// console.c ///

		void consoleinit ( void )
		{
			...
			ioapicenable( IRQ_KBD, 0 );
		}


		/// ide.c ///

		void ideinit ( void )
		{
			...
			ioapicenable( IRQ_IDE, ncpu - 1 );
			...
		}


	. The timer chip is inside the LAPIC so that each processor
	  can receive timer interrupts independently...
	. Xv6 sets it up in 'lapicinit'
	. It tells the LAPIC to periodically generate an interrupt
	  at IRQ_TIMER

		lapicw( TIMER, PERIODIC | ( T_IRQ0 + IRQ_TIMER ) );

	. The time interrupts through vector 32
		. T_IRQ0 + IRQ_TIMER
		  32     + 0

	. When 'trap' is called for a time interrupt, it does
	  two things:
		. increment the ticks variable
		. calls 'wakeup'??
		  wakeup may cause the interrupt to return into a
		  different process

		case T_IRQ0 + IRQ_TIMER:

			...

			ticks += 1;

			wakeup( &ticks );

			...


	. Note the only difference between vector 32 and
	  vector 64 (for system calls) is that vector 32 is an
	  interrupt gate instead of a trap gate.
	. Interrupt gates disable interrupts while handling the
	  current interrupt, while traps do not.


Drivers

	. A driver is the code in an OS that manages a particular device.
	. It tells the device hardware to perform operations,
	  configures the device to generate interrupts when done,
	  and handles the resulting interrupts

	. Driver code can be tricky to write because:
		. a driver executes concurrently with the device it manages
		. the driver must understand the device's interface
		  (e.g. which IO ports do what). The interface can be complex
		  and poorly documented


Disk driver

	. The disk driver copies data from and to the disk
	. Disk hardware traditionally presents the data on the disk as
	  a numbered sequence of 512-byte blocks (also called sectors)
	. The block size that an OS uses for its file system might be
	  different than the sector size that the disk uses
		. Xv6's block size is identical to the disk's

	. To represent a block, Xv6 has a "struct buf"
	. The data stored in this structure is often out of sync with the
	  disk.
	. It might not yet have been read in from disk, or it might
	  have been updated but not yet written out to disk
	. The disk driver must ensure that the rest of Xv6 does not get
	  confused when the structure is out of sync with the disk

		struct buf {

			int               flags;
			uint              dev;
			uint              blockno;
			struct sleeplock  lock;
			uint              refcnt;
			struct buf       *prev;    // LRU cache list
			struct buf       *next;
			struct buf       *qnext;   // disk queue
			uchar             data [ BSIZE ];
		};

		#define B_VALID 0x2  // buffer has been read from disk
		#define B_DIRTY 0x4  // buffer needs to be written to disk


	~~~ IDE device ~~~

	. IDE controller provides access to connected disks
	. Falling out of fashion in favour of SCSI and SATA

	. Xv6 represents fs blocks using "struct buf"
	. BSIZE is identical to the IDE's sector size, thus each buffer
	  represents the contents of one sector on a particular disk
	  device
	. buf->dev holds the device number
	. buf->data is an in-memorry copy of the disk sector
	. buf->flag tracks the relationship between memory and disk:
		. B_VALID means data has been read in
		. B_DIRTY means data needs to be written out

	. The Xv6 disk driver can handle a BSIZE that is a
	  multiple of the device's sector size
	. OSes often use blocks bigger than 512 bytes


	~~~ ideinit ~~~

	. The kernel initializes the disk driver at boot time by
	  calling 'ideinit'
	. ideinit calls ioapicenable to enable the IDE_IRQ interrupt.
	. The interrupt is enabled only on the last CPU.

		ioapicenable( IRQ_IDE, ncpu - 1 );

		idewait( 0 );

	. Next, ideinit probes the disk hardware.
	. It begins by calling 'idewait' to wait for the disk to be
	  able to accept commands
	. A PC motherboard presents the status bits of the disk
	  hardware on IO port 0x1F7.
	. idewait polls the status bits until the busy bit (IDE_BSY)
	  is clear and the ready bit (IDE_DRDY) is set

		static int idewait ( int checkerr )
		{
			...

			while ( ( ( r = inb( 0x1f7 ) ) & ( IDE_BSY | IDE_DRDY ) ) != IDE_DRDY )
			{
				//
			}

			...
		}

	. Now that the disk controller is ready, ideinit can check
	  how many disks are present
	. It assumes disk 0 is present because the boot loader and
	  kernel were both loaded from there
	. It writes to IO port 0x1F6 to select disk 1, and then waits
	  a while for the status bit to show that the disk is ready.
	. If not, ideinit assumes the disk is absent

		outb( 0x1f6, 0xe0 | ( 1 << 4 ) );  // select disk 1

		for ( i = 0; i < 1000; i += 1 )
		{
			if ( inb( 0x1f7 ) != 0 )
			{
				havedisk1 = 1;

				break;
			}
		}


	~~~ iderw ~~~

	. After ideinit, the disk is not used again until the buffer
	  cache calls 'iderw'

		struct buf* bread ( uint dev, uint blockno )
		{
			...

			if ( ( b->flags & B_VALID ) == 0 )
			{
				iderw( b );
			}

			...
		}

		void bwrite ( struct buf *b )
		{
			...

			b->flags |= B_DIRTY;

			iderw( b );
		}

	. iderw writes the buffer to disk if the B_DIRTY flag is set, and
	  reads the buffer from disk if B_VALID is not set (clear)

	. Disk accesses typically take milliseconds, a long time for a
	  processor.
	. The boot loader uses pollling (busy waiting). This is fine
	  because there is nothing else to do.
	. In an OS however, it is more efficient to let another process
	  run and arrange to receive an interrupt when the disk operation
	  has completed
	. iderw keeps a list of pending disk requests, and uses interrupts
	  to find out when each request has finished
	. Although iderw maintans a queue of requests, the simple IDE
	  controller can handle only one operation at a time

	. iderw adds the buffer "b" to the end of the queue

		b->qnext = 0;

		for ( pp = &idequeue; *pp; pp = &( *pp )->qnext )
		{
			//
		}

		*pp = b;


	. If the buffer is at the front of the queue, iderw must send
	  it to the disk hardware by calling 'idestart'??
	. Otherwise the buffer will be started once the buffers ahead
	  of it are taken care of

		if ( idequeue == b )
		{
			idestart( b );
		}

	. idestart issues either a read or a write for the buffer's
	  device and sector, according to the flags
	. If the operation is a write, idestart must supply the
	  data now (using 'outsl') and the interrupt will signal
	  that the data has been written to disk
	. If the operation is a read, the interrupt will signal that
	  the data is ready, and the handler will read it into b

		static void idestart ( struct buf *b )
		{
			...

			outb( ... );

			...

			if ( b->flags & B_DIRTY )
			{
				outb( 0x1f7, write_cmd );
				outsl( 0x1f0, b->data, BSIZE / 4 );
			}
			else
			{
				outb( 0x1f7, read_cmd );
			}
		}	

	. Having added the request to the queue and started it if
	  necessary?, iderw must wait for the result
	. iderw sleeps, waiting for the interrupt handler to record
	  in the buffer's flags that the operation is done
	. While the process is sleeping, Xv6 will schedule other
	  processes to keep the CPU busy

		while ( ( b->flags & ( B_VALID | B_DIRTY ) ) != B_VALID )
		{
			sleep( b, &idelock );
		}

	. Eventually, the disk will finish its operation and trigger
	  an interrupt.
	. trap will call 'ideintr' to handle it

		case T_IRQ0 + IRQ_IDE:

			ideintr();

			...


	. ideintr consults the first buffer in the queue to find out
	  which operation was happening
	. If the buffer was being read into and the disk controller
	  has data waiting, ideintr reads the data into the buffer
	  with 'insl'

		if ( ! ( b->flags & B_DIRTY ) && idewait( 1 ) >= 0 )
		{
			insl( 0x1f0, b->data, BSIZE / 4 );
		}

	. The buffer is now ready.
	. ideintr sets B_VALID and clears B_DIRTY, and
	  wakes up any? process waiting on the buffer?

		b->flags |= B_VALID;
		b->flags &= ~ B_DIRTY;

		wakeup( b );


	. Finally identr must pass the next waiting buffer to the disk

		idequeue = b->qnext;

		...

		if ( idequeue != 0 )
		{
			idestart( idequeue );
		}


---------------------------------------------------------------------------------------------
Locking
---------------------------------------------------------------------------------------------































---------------------------------------------------------------------------------------------
Scheduling
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
File system
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
Summary
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
PC hardware
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------
The boot loader
---------------------------------------------------------------------------------------------

...

	. When a x86 PC boots, it starts executing a program called the BIOS
	  (Basic Input/Output System) which is stored in non-volatile memory
	  on the motherboard
	. The BIOS's job is to prepare the hardware and then transfer control
	  to the OS
	. Specifically, it transfers control to code loaded from the
	  *boot sector* - the first 512 byte sector of the boot disk...
	. The boot sector contains the *boot loader* - instructions that
	  load the kernel into memory

	. The BIOS loads the boot sector at memory address 0x7C00 and then
	  jumps (sets the CPU's instruction pointer) to that address

	. When the boot loader begins executing, the CPU is simulating
	  an Intel 8088
	. The loader's job is to:
		. put the processor in a more modern operating mode,
		. load the Xv6 kernel from disk into memory,
		. and then transfer control to the kernel

	. The Xv6 bootloader comprises two files:
		. "bootasm.S" - written in a combniation of 16bit and 32bit assembly
		. "bootmain.c"

Assembly bootstrap

	. The first instruction in the boot loader is "cli", which disables
	  processor interrupts
	. The BIOS is a tiny OS and it might have setup its own interrupt
	  handlers as part of initializing the hardware
	. When Xv6 is ready, it will re-enable interrupts

	. The processor is in real mode, and is simulating an Intel 8088


	~~~ Real mode addressing ~~~

	. In real mode there are eight 16bit general purpose registeres
	. Since the processor sends 20bits of address to memory,
	  16bit segment registers (cs, ds, es, ss) are used to provide
	  the additional bits
	. Which segment register is used is implied by the type of
	  memory reference:
		. cs - instruction fetches
		. ds - data read and write
		. ss - stack read and write
	. When a program refers to memory, the CPU automatically
	  adds 16 times the value of a segment ergister...
	  The generated address is called the "linear address"

	. Xv6 pretends that an x86 instruction uses a "virtual address"
	  for its memory operands?? but an instruction actually uses
	  a "logical address"??
	. A "logical address" consists of a segment selector and an
	  offset.
	. It is sometimes written as "segment:offset".
	  More often the segment is implicit, and the program only
	  directly manipulates the offset

	. The segmentation hardware transforms the "logical address"
	  into a "linear address"
	. If paging hardware is enabled, it translates linear addresses
	  into "physical addresses".
	  Otherwise the processor uses linear addresses as physical

	  ------------
	  CPU
	  ------------
	       |
	       |       <--- logical address
	       V
	  ------------
	  segmentation
	  hardware
	  ------------
	       |
	       |       <--- linear address
	       V
	  ------------
	  paging
	  hardware
	  ------------
	       |
	       |       <--- physical address
	       V
	  ------------
	  RAM
	  ------------

	. After cli, the next thing the boot loader does is set
	  the segment registers to zero (known state)

		xorw   %ax, %ax   # Set %ax to zero
		movw   %ax, %ds   # -> Data Segment
		movw   %ax, %es   # -> Extra Segment
		movw   %ax, %ss   # -> Stack Segment

	. The next step is some hack to compensate for the fact
	  that a virtual "segment:offset" can yield a 21bit
	  physical address, whereas the Intel 8088 can only address
	  20bits of memory

		seta20.1:
			...

		seta20.2:
			...


	~~~ Switching to protected mode ~~~

	. The next step is to switch to 32bit "protected mode"

	. In protected mode, a segment register is an index into a
	  "segment descriptor table"...
	. Each entry in the table specifies:
		. a base physical address,
	  	. a maximum virtual address called the limit,
	  	. and permission bits for the segment
	. These permissions are the protection in protected mode.
	  The kernel can use them to ensure that a program uses only
	  its own memory

		 ... | ...   | ...      
		-----|-------|------
		base | limit | flags
		-----|-------|------
		base | limit | flags
		-----|-------|------
		base | limit | flags
		--------------------

	. Xv6 makes no use of segments, and uses the paging hardware instead
	. The boot loader sets up the segment descriptor table "gdt"
	  so that all segments:
		. have a base address of zero,
		. and the maximum possible limit (4Gbytes)
	. The table has three entries:??
		. a null entry,
		. one for executable code,
		. one for data
	. The code segment descriptor has a flag set (STA_X) that indicates
	  the code should run in 32bit mode...

	. The boot loader executes an "lgdt" instruction to load
	  the processor's GDT register with the value "gdtdesc"
	  which points to table gdt...

	. Once it has loaded the GDT register, the boot loader
	  enables protected mode by setting the appropriate
	  bit (CR0_PE) in the control register (cr0).

		/// bootasm.S ///

		lgdt  gdtdesc

		movl  %cr0,    %eax
		orl   $CR0_PE, %eax
		movl  %eax,    %cr0

		gdt:

			SEG_NULLASM                                # null seg
			SEG_ASM( STA_X | STA_R, 0x0, 0xffffffff )  # code seg
			SEG_ASM( STA_W,         0x0, 0xffffffff )  # data seg

		gdtdesc:

			.word  ( gdtdesc - gdt - 1 )  # sizeof( gdt ) - 1
			.long  gdt                    # address gdt


		/// asm.h ///

		#define STA_X  0x8  // Executable segment
		#define STA_W  0x2  // Writeable (non-executable segments)
		#define STA_R  0x2  // Readable (executable segments)

		#define SEG_NULLASM   \
			.word 0, 0;       \
			.byte 0, 0, 0, 0

		#define SEG_ASM ( type, base, lim )               \
			.word ( ( ( lim ) >> 12 ) & 0xffff ),         \
			      ( ( base ) & 0xffff );                  \
			.byte ( ( ( base ) >> 16 ) & 0xff ),          \
			      ( 0x90 | ( type ) ),                    \
			      ( 0xC0 | ( ( ( lim ) >> 28 ) & 0xf ) ), \
			      ( ( ( base ) >> 24 ) & 0xff )


	. Setting CR0_PE does not immediately change how the processor
	  translates logical addresses to physical.
	. The change takes effect only when one loads a new value
	  into a segment register...
	  A hack to do this is the following snippet which
	  writes the cs register...

		ljmpl  $( SEG_KCODE << 3 ), $( start32 )

		start32:
			...


	~~~ 32bit mode ~~~

	. The boot loader's first action in 32bit mode is to
	  initialize the data segment register (?) with SEG_KDATA

		movw  $( SEG_KDATA << 3 ), %ax  # Our data segment selector
		movw  %ax, %ds                  # -> DS: Data Segment
		movw  %ax, %es                  # -> ES: Extra Segment
		movw  %ax, %ss                  # -> SS: Stack Segment
		movw  $0,  %ax                  # Zero segments not ready for use
		movw  %ax, %fs                  # -> FS
		movw  %ax, %gs                  # -> GS

	. The next step before executing C code is to set up a stack
	  in an unused region of memory.
	. The boot loader chooses 0x7C00 as the top of the stack.
	  The stack will grow down from here, towards 0x0000 and
	  away from the boot loader

		start:

			cli

			...
		
			movl $start, %esp

			call bootmain


	. Memory looks like this...

		0xFFFF_FFFF -> --------------
		               ?
		0x0040_0000 -> --------------
		               reserved for kernel (Xv6 expects to be loaded here)
		0x0010_0000 -> --------------
		               IO devices?
		0x000A_0000 -> --------------
		               ?
		0x0000_7E00 -> --------------
		               boot loader (512 bytes)
		0x0000_7C00 -> --------------
		               stack
		0x0000_0000 -> --------------


	. The boot loader then calls the C function "bootmain"
	  which will load and run the kernel

C bootstrap

	. bootmain expects to find a copy of the kernel executable
	  on the disk starting at the second sector?
	. The kernel is an ELF format binary
	. To get access to the ELF headers, bootmain loads
	  the first 4096 bytes of the binary.
	  It places the in memory copy at address 0x0001_0000

		// ?
		elf = ( struct elfhdr* )0x10000;  // scratch space

		// Read 1st page off disk
		readseg( ( uchar* )elf, 4096, 0 );


	. The next step is a quick check that the ELF is a binary
	  and not an unitialized disk

		if ( elf->magic != ELF_MAGIC )
		{
			return;  // let bootasm.S handle error
		}


	. Bootmain then loads the content after the ELF header
	  into the memory address specified in kernel.ld
	. And zeros the remainder of the segment...

	. The kernel has been compiled and linked so that it
	  expects to find itself at virtual addresses starting
	  at 0x8010_0000
	. This virtual address is configured in kernel.ld
	. Once the kernel starts executing, it will set up the
	  paging hardware to map virtual addresses starting
	  at 0x8010_0000 to physical addresses starting at
	  0x0010_0000
	. This physical address is configured in kernel.ld
	. The boot loader uses this physical address
	  as where to load the kernel into memory

		ph = elf + elf->phoff;  // get program header

		pa = ph->paddr;         // get physical address of segment...


	. The boot loader's final step is to call the kernel's
	  entry point - the instruction the kernel expects to
	  start executing.
	. For Xv6 this address is 0x0010_000C
	. By convention, the "_start" symbol specifies the ELF
	  entry point
	. For Xv6, this is defined in "entry.S"

		# objdump -f kernel

		kernel:           file format elf32-i386
		architecture:     i386
		flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED
		start address:    0x0010000c


		// bootmain.c //
		entry = ( void( * )( void ) )( elf->entry );

		entry();


JK Summary

	. Most of this is legacy bloat.
	. Nothing useful happens here apart from the following:
		. load kernel from disk to where it expects to be in memory (RAM),
		. and jump to _start (entry.S)


---------------------------------------------------------------------------------------------
Other
---------------------------------------------------------------------------------------------

x86 processor supports Xv6 via:

	. kernel and user mode
		. switch between two
			. 'sysenter', 'sysexit' instructions
		. priviledged instructions
		. detect when user mode trying to execute priviledged

	. page table ??
		. translate virtual addresses to physical...

	. 'ltr' instruction
	. 'lidt' instruction
	. 'lgdt' instruction


---------------------------------------------------------------------------------------------
Other2
---------------------------------------------------------------------------------------------

Makefile - ??

	fs.img -> mkfs -> mkfs.c
	                  fs.h
	                  ulib
	                  uprogs

	Xv6.img -> bootblock -> bootasm.S
	                        bootmain.c
	        -> kernel    -> objs
	                        entry.S
	                        entryother.S
	                        initcode.S


Makefile - ??

	. 'Ttext' linker flag sets start address of .text section.
	. Thus the following:

		bootblock: $(SRCDIR)bootasm.S $(SRCDIR)bootmain.c
			...
			$(LD) $(LDFLAGS) -Ttext 0x7C00 ...
			...

		entryother: $(SRCDIR)entryother.S
			...
			$(LD) $(LDFLAGS) -Ttext 0x7000 ...

		initcode: $(SRCDIR)initcode.S
			....
			$(LD) $(LDFLAGS) -Ttext 0 ...
			....

	. Becomes:

		bin/bootblock.o:

			Disassembly of section .text:

			00007c00 <start>:
			    7c00:       fa                      cli
			    7c01:       31 c0                   xor    %eax,%eax
			    7c03:       8e d8                   mov    %eax,%ds
			    7c05:       8e c0                   mov    %eax,%es
			    7c07:       8e d0                   mov    %eax,%ss

			00007c09 <seta20.1>:
			    7c09:       e4 64                   in     $0x64,%al
			    7c0b:       a8 02                   test   $0x2,%al
			    7c0d:       75 fa                   jne    7c09 <seta20.1>
			...

		bin/bootblockother.o:

			Disassembly of section .text:

			00007000 <start>:
			    7000:       fa                      cli
			    7001:       31 c0                   xor    %eax,%eax
			...

		bin/initcode.out:

			Disassembly of section .text:

			00000000 <start>:
			       0:   68 24 00 00 00              push   $0x24
			       5:   68 1c 00 00 00              push   $0x1c
			...

	. Which is useful for relocation??


Makefile - Creating the disk image

	. Allocates space of size 512 * 10,000 (count) bytes.
	  All the bytes are set to zero.
	. Copy "img/bootblock" to first sector
	. Copy "img/kernel" starting at second sector

		Xv6.img: bootblock kernel

			dd if=/dev/zero          of=$(IMGDIR)Xv6.img count=10000          # zero out 512*count bytes

			dd if=$(IMGDIR)bootblock of=$(IMGDIR)Xv6.img        conv=notrunc  # first sector (512 bytes)
			dd if=$(IMGDIR)kernel    of=$(IMGDIR)Xv6.img seek=1 conv=notrunc  # second sector


EFLAGS register

	. https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture

	 0 - carry flag
	 1 - x
	 2 - parity flag
	 3 - x
	 4 - adjust flag
	 5 - x
	 6 - zero flag
	 7 - sign flag
	 8 - trap flag
	 9 - interrupt flag
	10 - stream direction flag
	11 - overflow flag
	12 - IO privilege level (IOPL)
	13 - ''' 
	14 - nested task flag
	15 - x
	16 - resume flag
	17 - virtual 8086 mode
	18 - alignment check
	19 - virtual interrupt flag (VIF)
	20 - virtual interrupt pending flag
	21 - identification flag

Contorol registers

	. CRO

	 0 - protected mode enable
	 1 - ?
	 2 - x87 FPU present
	 3 - save x87 task context on task switch
	 4 - external math co-processor
	 5 - enable x87 error reporting
	16 - when set, CPU can't write to read-only pages when privilege level is 0
	18 - alignment mask
	29 - enable write-through caching
	30 - enable memory cache
	31 - enable paging

	. CR1 - reserved...

	. CR2 - page fault linear address
	        When a page fault occcurs, stores the address the program
	        attempted to access

	. CR3 - physical base address of page directory

	. CR4

		. https://en.wikipedia.org/wiki/Control_register
		. https://wiki.osdev.org/CPU_Registers_x86

	 0 - enable VIF in 8086 mode
	 1 - enable VIF in protected mode
	 2 - time stamp disable
	 3 - enable something debug IO
	 4 - page size extension (0 - page size is 4Kib, 1 - 4MiB)
	 5 - physical address extension (translate 32bit addresses into 36bit)
	 6 - blah
	 7 - blah
	 8 - blah
	 9 - blah
	10 - blah
	11 - blah
	12 - blah
	13 - blah
	14 - blah
	15 - x
	16 - blah
	17 - blah
	18 - blah
	19 - x
	20 - blah
	21 - blah
	22 - blah

